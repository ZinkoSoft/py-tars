# ops/compose.yaml
# Usage:
#   docker compose -f ops/compose.yaml up --build
#
# This file reuses ONE generic Dockerfile (docker/app.Dockerfile) for all apps.
# Each service passes different build args (APP_PATH, APP_MODULE) to build its image.
#
# Repo assumptions (monorepo layout):
#   /apps/router, /apps/tts-worker, /apps/stt-worker
#   /packages/tars-core
#   /docker/app.Dockerfile  (this file references it)
#
# Notes:
# - The apps implement retry-on-connect to MQTT; strict health ordering isn't required.
# - If you provide console scripts in pyproject.toml, you can replace `command:` with them.

name: tars-stack

services:
  mqtt:
    env_file: ../.env
    image: eclipse-mosquitto:2
    container_name: tars-mqtt
    ports:
      - "1883:1883"
    volumes:
      - ./mosquitto.conf:/mosquitto/config/mosquitto.conf:ro
      - ./mosquitto-data:/mosquitto/data
      - ./mosquitto-config:/mosquitto/config
      # volumes:
      #   - ./mosquitto:/mosquitto   # optional: supply custom config/persistence
    restart: unless-stopped
    
  router:
    build:
      context: ..                      # root of the repo
      dockerfile: docker/app.Dockerfile
      args:
        PY_VERSION: "3.11"
        APP_PATH: apps/router
        CONTRACTS_PATH: packages/tars-core
        APP_MODULE: main
    env_file: .env
    image: tars/router:dev
    container_name: tars-router
    environment:
      MQTT_URL: mqtt://mqtt:1883
      MQTT_HOST: mqtt
      MQTT_PORT: "1883"
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      ROUTER_LLM_TTS_STREAM: ${ROUTER_LLM_TTS_STREAM:-1}
      TOPIC_LLM_STREAM: ${TOPIC_LLM_STREAM:-llm/stream}
      TOPIC_LLM_RESPONSE: ${TOPIC_LLM_RESPONSE:-llm/response}
      TOPIC_LLM_CANCEL: ${TOPIC_LLM_CANCEL:-llm/cancel}
      TOPIC_TTS_SAY: ${TOPIC_TTS_SAY:-tts/say}
      ROUTER_STREAM_MIN_CHARS: ${STREAM_MIN_CHARS:-60}
      ROUTER_STREAM_MAX_CHARS: ${STREAM_MAX_CHARS:-240}
      ROUTER_STREAM_BOUNDARY_CHARS: ${STREAM_BOUNDARY_CHARS:-.!?;:}
      ROUTER_TTS_VOICE: ${ROUTER_TTS_VOICE:-/voices/TARS.onnx}
    depends_on:
      mqtt:
        condition: service_started
    # If router defines a console script `tars-router`, you can use:
    # command: ["tars-router"]
    restart: unless-stopped

  tts:
    build:
      context: ..
      dockerfile: docker/specialized/tts-worker.Dockerfile
    image: tars/tts:dev
    container_name: tars-tts
    env_file: .env
    environment:
      MQTT_URL: mqtt://mqtt:1883
      MQTT_HOST: mqtt
      MQTT_PORT: "1883"
      PIPER_VOICE: /voices/TARS.onnx
      PULSE_RUNTIME_PATH: /run/user/1000/pulse
      PULSE_SERVER: unix:/run/user/1000/pulse/native
      TTS_STREAMING: ${TTS_STREAMING:-0}
      TTS_PIPELINE: ${TTS_PIPELINE:-1}
      TTS_WAKE_CACHE_ENABLE: ${TTS_WAKE_CACHE_ENABLE:-1}
      TTS_WAKE_CACHE_DIR: ${TTS_WAKE_CACHE_DIR:-/tmp/tars/wake-ack}
      TTS_WAKE_CACHE_MAX: ${TTS_WAKE_CACHE_MAX:-16}

    depends_on:
      mqtt:
        condition: service_started
    # Image entrypoint handles startup
    restart: unless-stopped
    # Example of mounting voices/models if needed
    volumes:
      - ../apps/tts-worker/voices:/voice-models:ro
      - /run/user/1000/pulse:/run/user/1000/pulse:ro

  stt:
    build:
      context: ..
      dockerfile: docker/specialized/stt-worker.Dockerfile
    image: tars/stt:dev
    container_name: tars-stt
    env_file: .env
    environment:
      # Broker URL assembled from global creds/host/port
      MQTT_URL: mqtt://mqtt:1883
      MQTT_HOST: mqtt
      MQTT_PORT: "1883"
      # Whisper model and logging
      WHISPER_MODEL: ${WHISPER_MODEL:-small}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      # Backend selection and remote WS URL (if STT_BACKEND=ws)
      STT_BACKEND: ${STT_BACKEND:-whisper}
      WS_URL: ${WS_URL:-ws://127.0.0.1:9000/stt}
      PULSE_RUNTIME_PATH: /run/user/1000/pulse
      PULSE_SERVER: unix:/run/user/1000/pulse/native
      # Audio/VAD
      SILENCE_THRESHOLD_MS: ${SILENCE_THRESHOLD_MS:-600}
      CHUNK_DURATION_MS: ${CHUNK_DURATION_MS:-20}
      VAD_AGGRESSIVENESS: ${VAD_AGGRESSIVENESS:-3}
      SAMPLE_RATE: ${SAMPLE_RATE:-16000}
      AUDIO_FANOUT_PATH: ${WAKE_AUDIO_FANOUT:-/tmp/tars/audio-fanout.sock}
      FFT_PUBLISH: ${FFT_PUBLISH:-0}
      FFT_RATE_HZ: ${FFT_RATE_HZ:-12}
      FFT_BINS: ${FFT_BINS:-64}
      FFT_LOG_SCALE: ${FFT_LOG_SCALE:-1}
      FFT_WS_ENABLE: ${FFT_WS_ENABLE:-1}
      FFT_WS_HOST: ${FFT_WS_HOST:-0.0.0.0}
      FFT_WS_PORT: ${FFT_WS_PORT:-8765}
      FFT_WS_PATH: ${FFT_WS_PATH:-/fft}
    depends_on:
      mqtt:
        condition: service_started
    restart: unless-stopped
    devices:
      - /dev/snd:/dev/snd
    volumes:
      - /run/user/1000/pulse:/run/user/1000/pulse:ro
      - ../models/whisper:/host-models
      - wake-cache:/tmp/tars

  wake-activation:
    build:
      context: ..
      dockerfile: docker/specialized/wake-activation.Dockerfile
      args:
        PY_VERSION: "3.11"
        APP_PATH: apps/wake-activation
        CONTRACTS_PATH: packages/tars-core
        APP_MODULE: wake_activation
    image: tars/wake-activation:dev
    container_name: tars-wake-activation
    env_file: .env
    environment:
      MQTT_URL: mqtt://mqtt:1883
      MQTT_HOST: mqtt
      MQTT_PORT: "1883"
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      WAKE_AUDIO_FANOUT: ${WAKE_AUDIO_FANOUT:-/tmp/tars/audio-fanout.sock}
      WAKE_MODEL_PATH: ${WAKE_MODEL_PATH:-/models/openwakeword/hey_tars.tflite}
    depends_on:
      mqtt:
        condition: service_started
      stt:
        condition: service_started
    volumes:
      - ../models/openwakeword:/models/openwakeword:ro
      - wake-cache:/tmp/tars
    restart: unless-stopped

  ui-web:
    build:
      context: ..
      dockerfile: docker/specialized/ui-web.Dockerfile
      args:
        SERVICE_PATH: apps/ui-web
    image: tars/ui-web:dev
    container_name: tars-ui-web
    env_file: .env
    environment:
      MQTT_URL: mqtt://mqtt:1883
      MQTT_HOST: mqtt
      MQTT_PORT: "1883"
      HOST: 0.0.0.0
      PORT: "5010"
    ports:
      - "5010:5010"
    depends_on:
      mqtt:
        condition: service_started
    restart: unless-stopped

  camera:
    build:
      context: ..
      dockerfile: docker/specialized/camera-service.Dockerfile
    image: tars/camera:dev
    container_name: tars-camera
    env_file: .env
    environment:
      MQTT_URL: mqtt://mqtt:1883
      MQTT_HOST: mqtt
      MQTT_PORT: "1883"
      CAMERA_WIDTH: ${CAMERA_WIDTH:-640}
      CAMERA_HEIGHT: ${CAMERA_HEIGHT:-480}
      CAMERA_FPS: ${CAMERA_FPS:-10}
      CAMERA_QUALITY: ${CAMERA_QUALITY:-80}
      CAMERA_ROTATION: ${CAMERA_ROTATION:-0}
      CAMERA_MQTT_RATE: ${CAMERA_MQTT_RATE:-2}
      CAMERA_HTTP_HOST: 0.0.0.0
      CAMERA_HTTP_PORT: ${CAMERA_HTTP_PORT:-8080}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    ports:
      - "${CAMERA_HTTP_PORT:-8080}:${CAMERA_HTTP_PORT:-8080}"
    depends_on:
      mqtt:
        condition: service_started
    restart: unless-stopped
    devices:
      - /dev/video0:/dev/video0
    privileged: true

  ui:
    build:
      context: ..
      dockerfile: docker/specialized/ui.Dockerfile
    image: tars/ui:dev
    container_name: tars-ui
    env_file: .env
    environment:
      MQTT_URL: mqtt://mqtt:1883
      MQTT_HOST: mqtt
      MQTT_PORT: "1883"
      UI_CONFIG: /config/ui.toml
      DISPLAY: ${DISPLAY:-:1}
      SDL_VIDEODRIVER: ${SDL_VIDEODRIVER:-x11}
      XAUTHORITY: ${XAUTHORITY:-/tmp/.docker_xauth}
      FFT_WS_ENABLE: 1
      FFT_WS_HOST: 0.0.0.0
      FFT_WS_PORT: 8765
      FFT_WS_PATH: /fft
    depends_on:
      mqtt:
        condition: service_started
    volumes:
      - ../apps/ui/ui.toml:/config/ui.toml:ro
      - /tmp/.X11-unix:/tmp/.X11-unix:rw
      - /run/user/1000/gdm/Xauthority:${XAUTHORITY:-/tmp/.docker_xauth}:ro
    restart: unless-stopped

  llm:
    build:
      context: ..
      dockerfile: docker/specialized/llm-worker.Dockerfile
    image: tars/llm:dev
    container_name: tars-llm
    env_file: .env
    environment:
      MQTT_URL: mqtt://mqtt:1883
      MQTT_HOST: mqtt
      MQTT_PORT: "1883"
      LOG_LEVEL: "INFO"
      LLM_PROVIDER: openai
      LLM_MODEL: gpt-4o-mini
      LLM_MAX_TOKENS: "512"
      LLM_TEMPERATURE: "0.7"
    depends_on:
      mqtt:
        condition: service_started
    restart: unless-stopped

  mcp-bridge:
    build:
      context: ..
      dockerfile: docker/specialized/mcp-bridge.Dockerfile
    image: tars/mcp-bridge:dev
    container_name: tars-mcp-bridge
    env_file: .env
    environment:
      MQTT_URL: mqtt://mqtt:1883
      MQTT_HOST: mqtt
      MQTT_PORT: "1883"
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
      MCP_SERVERS_YAML: /config/mcp.server.yml
    volumes:
      - ../ops/mcp/mcp.server.yml:/config/mcp.server.yml:ro
      - ..:/workspace
    depends_on:
      mqtt:
        condition: service_started
    restart: unless-stopped

# Optional: define multiple network(s)
networks:
  default:
    name: tars-net
    driver: bridge

volumes:
  wake-cache:
    driver: local
