# MQTT Client API Contract
# Feature: Centralized MQTT Client
# Branch: 004-centralize-mqtt-client
# Version: 1.0.0

# This document defines the public API contract for the centralized MQTT client module
# using OpenAPI-inspired YAML format for clarity and tooling support.

components:
  schemas:
    # Configuration Models
    
    MQTTClientConfig:
      type: object
      description: Configuration for initializing MQTTClient from environment
      required:
        - mqtt_url
        - client_id
      properties:
        mqtt_url:
          type: string
          format: uri
          pattern: '^mqtt://'
          description: MQTT broker connection URL
          example: "mqtt://user:pass@localhost:1883"
        client_id:
          type: string
          minLength: 1
          description: Unique client identifier for broker
          example: "tars-stt"
        source_name:
          type: string
          nullable: true
          description: Source identifier for Envelope messages (defaults to client_id)
          example: "stt-worker"
        keepalive:
          type: integer
          minimum: 1
          maximum: 3600
          default: 60
          description: MQTT protocol keepalive interval in seconds
        enable_health:
          type: boolean
          default: false
          description: Enable automatic health status publishing
        enable_heartbeat:
          type: boolean
          default: false
          description: Enable application-level heartbeat publishing
        heartbeat_interval:
          type: number
          format: float
          minimum: 1.0
          default: 5.0
          description: Heartbeat publishing interval in seconds
        dedupe_ttl:
          type: number
          format: float
          minimum: 0
          default: 0
          description: Message deduplication TTL in seconds (0=disabled)
        dedupe_max_entries:
          type: integer
          minimum: 0
          default: 0
          description: Max deduplication cache entries (0=disabled)
        reconnect_min_delay:
          type: number
          format: float
          minimum: 0.1
          default: 0.5
          description: Minimum reconnection backoff delay in seconds
        reconnect_max_delay:
          type: number
          format: float
          minimum: 0.5
          default: 5.0
          description: Maximum reconnection backoff delay in seconds
    
    ConnectionParams:
      type: object
      description: Parsed MQTT connection parameters from URL
      required:
        - hostname
        - port
      properties:
        hostname:
          type: string
          description: MQTT broker hostname or IP address
          example: "localhost"
        port:
          type: integer
          minimum: 1
          maximum: 65535
          description: MQTT broker port
          example: 1883
        username:
          type: string
          nullable: true
          description: Authentication username
        password:
          type: string
          format: password
          nullable: true
          description: Authentication password
    
    # Message Models
    
    HealthStatus:
      type: object
      description: Health status payload for system/health/{client_id} topic
      required:
        - ok
      properties:
        ok:
          type: boolean
          description: Health status indicator
        event:
          type: string
          nullable: true
          description: Health event name
          enum:
            - ready
            - reconnected
            - shutdown
            - error
          example: "ready"
        error:
          type: string
          nullable: true
          description: Error message if ok=false
        timestamp:
          type: number
          format: float
          nullable: true
          description: Unix timestamp (auto-generated by Envelope)
    
    HeartbeatPayload:
      type: object
      description: Application-level keepalive heartbeat payload
      required:
        - ok
        - event
        - timestamp
      properties:
        ok:
          type: boolean
          const: true
          description: Always true for heartbeat
        event:
          type: string
          const: "heartbeat"
          description: Event type identifier
        timestamp:
          type: number
          format: float
          description: Unix timestamp of heartbeat
    
    # Handler Types
    
    SubscriptionHandler:
      type: object
      description: Type contract for subscription handler functions
      x-python-type: "Callable[[bytes], Awaitable[None]]"
      properties:
        input:
          type: string
          format: byte
          description: Raw message payload
        output:
          type: "null"
          description: Handlers perform side effects, no return value
      
# API Methods

methods:
  
  # Lifecycle Methods
  
  connect:
    description: Connect to MQTT broker and start background tasks
    parameters: []
    returns:
      type: "null"
    raises:
      - ConnectionError: "Failed to connect to MQTT broker"
      - ValueError: "Invalid MQTT URL format"
    state_transitions:
      from: ["Created", "Disconnected"]
      to: "Connected"
    side_effects:
      - "Creates asyncio-mqtt Client instance"
      - "Subscribes to all registered topics"
      - "Starts message dispatch background task"
      - "Starts heartbeat background task (if enabled)"
    
  disconnect:
    description: Disconnect from MQTT broker and stop background tasks
    parameters: []
    returns:
      type: "null"
    raises: []
    state_transitions:
      from: ["Connected", "Reconnecting"]
      to: "Disconnected"
    side_effects:
      - "Cancels dispatch and heartbeat tasks"
      - "Closes MQTT client connection"
      - "Clears subscription state"
    
  shutdown:
    description: Gracefully shutdown client with health notification
    parameters: []
    returns:
      type: "null"
    raises: []
    state_transitions:
      from: ["any"]
      to: "Disconnected"
    side_effects:
      - "Publishes health(ok=false, event='shutdown') if enabled"
      - "Cancels background tasks with timeout"
      - "Disconnects MQTT client"
    idempotent: true
  
  # Publishing Methods
  
  publish_event:
    description: Publish event wrapped in Envelope to MQTT topic
    parameters:
      - name: topic
        type: string
        required: true
        description: MQTT topic to publish to
        example: "stt/final"
      - name: event_type
        type: string
        required: true
        description: Event type identifier for Envelope
        example: "stt.final"
      - name: data
        type: object
        required: true
        description: Event data (dict or Pydantic model)
        oneOf:
          - type: object
            additionalProperties: true
          - x-python-type: "BaseModel"
      - name: correlation_id
        type: string
        required: false
        nullable: true
        description: Correlation ID for request tracing
      - name: qos
        type: integer
        required: false
        default: 0
        minimum: 0
        maximum: 2
        description: MQTT Quality of Service level
      - name: retain
        type: boolean
        required: false
        default: false
        description: MQTT retain flag
    returns:
      type: "null"
    raises:
      - RuntimeError: "Not connected to MQTT broker"
      - ValidationError: "Invalid event data or Envelope structure"
    state_requirements:
      - "Connected"
    side_effects:
      - "Wraps data in Envelope with event_type, source, timestamp"
      - "Serializes Envelope to JSON using orjson"
      - "Publishes to MQTT broker with specified QoS and retain flags"
  
  publish_health:
    description: Publish health status to system/health/{client_id} topic
    parameters:
      - name: ok
        type: boolean
        required: true
        description: Health status indicator
      - name: event
        type: string
        required: false
        nullable: true
        description: Health event name
        enum: ["ready", "reconnected", "shutdown", "error"]
      - name: error
        type: string
        required: false
        nullable: true
        description: Error message if ok=false
    returns:
      type: "null"
    raises:
      - RuntimeError: "Health publishing not enabled"
    state_requirements:
      - "Connected"
    behavior:
      - "No-op if enable_health=false"
      - "Always publishes with QoS=1 and retain=true"
      - "Topic is system/health/{client_id}"
      - "Wraps in Envelope with event_type='health.status'"
  
  # Subscription Methods
  
  subscribe:
    description: Subscribe to MQTT topic with handler function
    parameters:
      - name: topic
        type: string
        required: true
        description: MQTT topic to subscribe to (supports wildcards)
        example: "stt/#"
      - name: handler
        required: true
        x-python-type: "Callable[[bytes], Awaitable[None]]"
        description: Async handler function for messages
      - name: qos
        type: integer
        required: false
        default: 0
        minimum: 0
        maximum: 2
        description: MQTT Quality of Service level
    returns:
      type: "null"
    raises:
      - RuntimeError: "Not connected to MQTT broker"
      - TypeError: "Handler is not async callable"
    state_requirements:
      - "Connected"
    side_effects:
      - "Registers handler in _handlers dict"
      - "Adds topic to _subscriptions set"
      - "Calls client.subscribe(topic, qos)"
      - "Handler invoked for each matching message in dispatch loop"
    idempotent: true
    notes:
      - "Multiple calls for same topic replace handler"
      - "Wildcards supported: # (multi-level), + (single-level)"
      - "Handler errors are logged and isolated (no crash)"
  
  # Property Accessors
  
  client:
    type: property
    description: Access underlying asyncio-mqtt Client instance
    returns:
      type: object
      nullable: true
      x-python-type: "mqtt.Client | None"
    usage: "Advanced operations not covered by wrapper API"
    warning: "Direct client access bypasses wrapper safeguards"
  
  connected:
    type: property
    description: Check if client is currently connected to broker
    returns:
      type: boolean
    usage: "State checking before publish/subscribe operations"

# Message Flow Contracts

message_flows:
  
  publish_with_envelope:
    description: Standard event publishing flow
    sequence:
      - step: 1
        action: "Service calls publish_event(topic, event_type, data)"
      - step: 2
        action: "MQTTClient wraps data in Envelope"
        envelope:
          id: "auto-generated ULID"
          type: "{event_type}"
          timestamp: "auto-generated Unix timestamp"
          source: "{source_name or client_id}"
          correlate: "{correlation_id or null}"
          data: "{data}"
      - step: 3
        action: "Serialize Envelope to JSON using orjson"
      - step: 4
        action: "Publish to MQTT broker: await client.publish(topic, payload, qos, retain)"
      - step: 5
        action: "Log publish event with correlation ID"
    
  subscribe_with_handler:
    description: Topic subscription and message dispatch flow
    sequence:
      - step: 1
        action: "Service calls subscribe(topic, handler, qos)"
      - step: 2
        action: "MQTTClient registers handler in _handlers[topic]"
      - step: 3
        action: "Subscribe to broker: await client.subscribe(topic, qos)"
      - step: 4
        action: "Dispatch task receives message from broker"
      - step: 5
        action: "Lookup handler for message topic"
      - step: 6
        action: "Check deduplication if enabled"
        condition: "dedupe_ttl > 0"
        true_path: "Skip if is_duplicate(payload)"
        false_path: "Continue to handler"
      - step: 7
        action: "Invoke handler: await handler(payload)"
        error_handling: "Log exception, continue dispatch loop"
  
  reconnection_flow:
    description: Automatic reconnection on connection loss
    sequence:
      - step: 1
        trigger: "Connection lost (exception in dispatch loop)"
      - step: 2
        action: "Transition to Reconnecting state"
      - step: 3
        action: "Calculate backoff_delay = min(current * 2, max_delay)"
      - step: 4
        action: "await asyncio.sleep(backoff_delay)"
      - step: 5
        action: "Attempt reconnect()"
        success: "Transition to Connected, reset backoff"
        failure: "Repeat from step 3"
      - step: 6
        action: "Re-subscribe to all topics in _subscriptions"
      - step: 7
        action: "Resume message dispatch"
  
  graceful_shutdown:
    description: Clean shutdown with health notification
    sequence:
      - step: 1
        action: "Service calls shutdown()"
      - step: 2
        action: "Publish health(ok=false, event='shutdown') if enabled"
      - step: 3
        action: "Cancel dispatch task"
      - step: 4
        action: "Cancel heartbeat task"
      - step: 5
        action: "await asyncio.gather(*tasks, return_exceptions=True)"
        timeout: "5 seconds"
      - step: 6
        action: "await client.__aexit__()"
      - step: 7
        action: "Transition to Disconnected state"

# QoS and Retain Guidelines

qos_retain_patterns:
  
  health_topics:
    topic_pattern: "system/health/{client_id}"
    qos: 1
    retain: true
    rationale: "Critical state that must persist across client restarts"
  
  command_topics:
    topic_pattern: "{domain}/request | {domain}/say | {domain}/query"
    qos: 1
    retain: false
    rationale: "Commands must be delivered but not replayed"
  
  response_topics:
    topic_pattern: "{domain}/response | {domain}/results"
    qos: 1
    retain: false
    rationale: "Responses must be delivered but not replayed"
  
  stream_topics:
    topic_pattern: "{domain}/stream | {domain}/partial"
    qos: 0
    retain: false
    rationale: "High-frequency data where loss is acceptable"
  
  keepalive_topics:
    topic_pattern: "system/keepalive/{client_id}"
    qos: 0
    retain: false
    rationale: "Transient liveness signal, no persistence needed"

# Error Handling

error_codes:
  
  CONNECTION_FAILED:
    description: "Failed to establish MQTT broker connection"
    http_equivalent: 503
    recovery: "Automatic reconnection with exponential backoff"
  
  NOT_CONNECTED:
    description: "Operation requires active connection"
    http_equivalent: 503
    recovery: "Wait for reconnection or call connect()"
  
  INVALID_URL:
    description: "MQTT URL format invalid"
    http_equivalent: 400
    recovery: "Fix MQTT_URL environment variable"
  
  VALIDATION_ERROR:
    description: "Message data failed Pydantic validation"
    http_equivalent: 400
    recovery: "Fix event data structure to match schema"
  
  HANDLER_ERROR:
    description: "Subscription handler raised exception"
    http_equivalent: 500
    recovery: "Error logged, dispatch continues (isolated)"
  
  SHUTDOWN_TIMEOUT:
    description: "Background tasks did not stop within timeout"
    http_equivalent: 500
    recovery: "Tasks forcefully cancelled, connection closed"

# Performance Characteristics

performance:
  
  publish_latency:
    target: "<10ms"
    measured: "Time from publish_event() call to MQTT publish completion"
    factors:
      - "Envelope serialization (orjson): ~1ms"
      - "MQTT publish: ~5ms local, ~10ms remote"
  
  reconnection_time:
    target: "<50ms"
    measured: "Time from connection loss to reconnected state"
    factors:
      - "Backoff delay: 0.5s â†’ 5s (exponential)"
      - "Broker handshake: ~10-20ms"
      - "Re-subscription: ~1ms per topic"
  
  message_throughput:
    target: "100+ messages/second"
    measured: "Messages processed through dispatch loop"
    factors:
      - "Handler execution time (dominant)"
      - "Deduplication overhead: ~0.1ms per message"
  
  memory_usage:
    baseline: "~5MB (client + buffers)"
    with_deduplication: "+2MB (2048 entries @ 1KB each)"
    with_handlers: "+negligible (handler registry)"

# Usage Examples

examples:
  
  basic_publish_subscribe:
    description: "Minimal usage pattern for most services"
    code: |
      # Initialize client
      config = MQTTClientConfig.from_env()
      client = MQTTClient(
          mqtt_url=config.mqtt_url,
          client_id=config.client_id,
          enable_health=True,
      )
      
      # Define subscription handler
      async def handle_message(payload: bytes) -> None:
          envelope = Envelope.model_validate_json(payload)
          logger.info("Received: %s", envelope.data)
      
      # Connect and subscribe
      await client.connect()
      await client.subscribe("my/topic", handle_message)
      await client.publish_health(ok=True, event="ready")
      
      # Publish events
      await client.publish_event(
          topic="my/response",
          event_type="my.response",
          data={"result": "success"},
          qos=1,
      )
      
      # Graceful shutdown
      await client.shutdown()
  
  advanced_with_heartbeat:
    description: "Service with heartbeat and deduplication"
    code: |
      client = MQTTClient(
          mqtt_url=MQTT_URL,
          client_id="tars-advanced",
          enable_health=True,
          enable_heartbeat=True,
          heartbeat_interval=5.0,
          dedupe_ttl=30.0,
          dedupe_max_entries=2048,
      )
      
      async with client:  # Context manager handles connect/shutdown
          await client.subscribe("events/#", event_handler)
          await client.publish_health(ok=True, event="ready")
          
          # Service logic...
          await asyncio.sleep(3600)  # Run for 1 hour
  
  service_migration:
    description: "Migrating from custom MQTT wrapper"
    before: |
      # Old pattern (custom wrapper)
      mqtt = MQTTClientWrapper(MQTT_URL, "tars-stt")
      await mqtt.connect()
      await mqtt.subscribe_stream("wake/event", handle_wake)
      await mqtt.safe_publish("stt/final", {"text": "hello"})
    after: |
      # New pattern (centralized client)
      client = MQTTClient(MQTT_URL, "tars-stt", enable_health=True)
      await client.connect()
      await client.subscribe("wake/event", handle_wake)
      await client.publish_event(
          topic="stt/final",
          event_type="stt.final",
          data={"text": "hello"},
      )

# Version History

versions:
  "1.0.0":
    date: "2025-10-16"
    changes:
      - "Initial API contract definition"
      - "Core methods: connect, disconnect, shutdown, publish_event, publish_health, subscribe"
      - "Configuration via MQTTClientConfig"
      - "Optional features: health, heartbeat, deduplication"
      - "Automatic reconnection with exponential backoff"
