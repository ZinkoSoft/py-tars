# Quick Reference: Using the Configuration Library

## For Service Developers

### 1. Add Dependency

Your service already has `tars-core` as a dependency. The config module is now available.

### 2. Define Your Service's Configuration Model

If your service doesn't have a config model yet, add it to `packages/tars-core/src/tars/config/models.py`:

```python
class MyServiceConfig(BaseModel):
    """Configuration for my-service."""
    model_config = ConfigDict(extra="forbid")
    
    my_setting: str = Field(
        default="default_value",
        description="User-facing description",
        json_schema_extra={"complexity": "simple", "type": "string"}
    )
    
    advanced_setting: int = Field(
        default=100,
        ge=0,
        le=1000,
        description="Advanced tuning parameter",
        json_schema_extra={"complexity": "advanced", "type": "integer"}
    )
```

### 3. Use Configuration in Your Service

```python
from tars.config.library import ConfigLibrary
from tars.config.models import MyServiceConfig

class MyService:
    def __init__(self):
        self.config_lib = ConfigLibrary(service_name="my-service")
        self.config: MyServiceConfig | None = None
    
    async def start(self) -> None:
        # Initialize library
        await self.config_lib.initialize()
        
        # Load configuration (auto-falls back to LKG cache if DB unavailable)
        self.config = await self.config_lib.get_config(MyServiceConfig)
        
        # Subscribe to runtime updates
        await self.config_lib.subscribe_updates(
            self._on_config_update,
            MyServiceConfig
        )
        
        print(f"Loaded config: {self.config}")
    
    async def _on_config_update(self, new_config: MyServiceConfig) -> None:
        """Called when configuration changes via MQTT."""
        print(f"Config updated: {new_config}")
        self.config = new_config
        # Apply changes as needed (some settings may require restart)
    
    async def shutdown(self) -> None:
        await self.config_lib.close()
```

### 4. Environment Variable Overrides

Users can override any setting via environment variables:

```bash
# Override my_setting
export MY_SETTING="production_value"

# Override advanced_setting
export ADVANCED_SETTING="500"
```

Precedence order: `.env` → database → defaults

### 5. Check Configuration Source

```python
# Check if in read-only fallback mode
if config_lib.is_read_only:
    print("Using LKG cache - database unavailable")

# Check database availability
if config_lib.database_available:
    print("Connected to config database")
```

## For Web UI Developers

### TypeScript Types (Phase 3)

```typescript
// types/config.ts
export interface ConfigField {
  key: string;
  value: any;
  type: 'string' | 'integer' | 'float' | 'boolean' | 'enum' | 'path' | 'secret';
  complexity: 'simple' | 'advanced';
  description: string;
  helpText?: string;
  validation?: {
    min?: number;
    max?: number;
    pattern?: string;
    allowed?: string[];
  };
}

export interface ServiceConfig {
  service: string;
  config: Record<string, any>;
  version: number;
  updated_at: string;
  config_epoch: string;
}
```

### REST API Endpoints (Phase 3)

```typescript
// GET /api/config/services
const services = await fetch('/api/config/services').then(r => r.json());

// GET /api/config/services/{service}
const config = await fetch('/api/config/services/stt-worker').then(r => r.json());

// PUT /api/config/services/{service}
await fetch('/api/config/services/stt-worker', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    service: 'stt-worker',
    config: { whisper_model: 'small.en' },
    version: 1  // For optimistic locking
  })
});
```

## For Operators

### Required Environment Variables

```bash
# Database
CONFIG_DB_PATH=/data/config/config.db
CONFIG_LKG_CACHE_PATH=/data/config/config.lkg.json

# Encryption (auto-generated on first run if missing)
CONFIG_MASTER_KEY_BASE64=<auto-generated>
CONFIG_MASTER_KEY_ID=<auto-generated>
LKG_HMAC_KEY_BASE64=<auto-generated>
CONFIG_SIGNATURE_PRIVATE_KEY=<auto-generated>
CONFIG_SIGNATURE_PUBLIC_KEY=<auto-generated>

# MQTT
MQTT_URL=mqtt://user:password@localhost:1883

# Optional: Litestream backups
LITESTREAM_S3_ENDPOINT=https://s3.amazonaws.com
LITESTREAM_S3_BUCKET=tars-config-backups
LITESTREAM_ACCESS_KEY_ID=<your-key>
LITESTREAM_SECRET_ACCESS_KEY=<your-secret>
```

### Troubleshooting

**Database locked**:
```bash
# Check WAL mode is enabled
sqlite3 /data/config/config.db "PRAGMA journal_mode;"
# Should return: wal
```

**Service in read-only mode**:
- Check database file permissions
- Verify LKG cache exists: `ls -la /data/config/config.lkg.json`
- Check logs for database errors

**MQTT signature verification failures**:
- Verify `CONFIG_SIGNATURE_PUBLIC_KEY` matches across all services
- Check system clock sync (signatures include timestamp)
- Ensure Ed25519 keys are valid PEM format

## Testing

### Run All Tests

```bash
cd packages/tars-core
make test
```

### Run Specific Test Types

```bash
# Unit tests only
pytest -m unit

# Integration tests (require DB)
pytest -m integration

# Contract tests (validate MQTT schemas)
pytest -m contract
```

### Manual Testing

```python
# Test encryption
from tars.config.crypto import encrypt_secret, decrypt_secret, generate_master_key

key, key_id = generate_master_key()
encrypted = encrypt_secret("my-secret", key)
decrypted = decrypt_secret(encrypted, key)
assert decrypted == "my-secret"

# Test configuration resolution
from tars.config.models import STTWorkerConfig
from tars.config.precedence import ConfigResolver

resolver = ConfigResolver()
config = resolver.resolve_config(STTWorkerConfig)
print(config)
```

## FAQ

**Q: What happens if the database is corrupted?**  
A: Services automatically fall back to the last-known-good (LKG) cache. The cache is HMAC-signed to detect tampering. Operators can rebuild the database via API or by setting `ALLOW_AUTO_REBUILD=1`.

**Q: Can I override database configs with environment variables?**  
A: Yes! Environment variables always take precedence. This allows operators to lock down critical settings.

**Q: How do I add a new configuration field?**  
A: Add it to your service's Pydantic model in `models.py`. The schema version will auto-increment on startup, and the database will be updated.

**Q: How do I rotate encryption keys?**  
A: Add new key with new ID to .env, restart config-manager. Re-encryption happens automatically. Remove old key after grace period.

**Q: Are configuration changes logged?**  
A: Yes! All changes are recorded in `config_history` table with timestamps, old/new values, and user identifiers.

---

**Status**: Phase 2 Complete - Library ready for use  
**Next**: Phase 3 will add REST API and web UI for configuration management
