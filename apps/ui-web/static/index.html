<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TARS Chat</title>
  <style>
    :root {
      --bg: #0a0a12; --panel: #0f1324; --border: #1e2545; --text: #e8ecff;
      --tars: #1d2b56; --user: #1d5637; --muted: #9aa4d6; --accent: #5ac8fa;
    }
    * { box-sizing: border-box; }
    body { background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; height:100vh; display:flex; flex-direction:column; }
    header { padding:12px 16px; border-bottom:1px solid var(--border); background:#0c1020; display:flex; align-items:center; justify-content:space-between; gap:12px; }
    header h1 { margin:0; font-size:16px; color:var(--muted); font-weight:600; }
    .toolbar { display:flex; gap:8px; }
    .btn { background:transparent; color:var(--muted); border:1px solid var(--border); padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    .btn:hover { color:#fff; border-color:#2a3469; background:#0b132e; }
    #container { display:flex; gap:16px; padding:16px; height:100%; }
    #left { flex:1; display:flex; flex-direction:column; gap:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    #chat { flex:1; display:flex; flex-direction:column; }
    #log { padding:12px; overflow:auto; height:100%; scroll-behavior:smooth; }
    .row { display:flex; margin:8px 0; }
    .bubble { max-width:72%; padding:10px 12px; border-radius:12px; line-height:1.3; }
    .tars { background:var(--tars); border:1px solid #2e3c78; border-top-left-radius:4px; }
    .user { background:var(--user); border:1px solid #2c7a51; margin-left:auto; border-top-right-radius:4px; }
    .meta { font-size:12px; color:var(--muted); margin:6px 2px 0 2px; }
    .status { padding:10px 12px; font-size:13px; color:var(--muted); display:flex; align-items:center; gap:8px; }
    .dot { width:8px; height:8px; border-radius:50%; background:var(--muted); opacity:0.7; }
    .typing { display:inline-flex; gap:4px; align-items:center; }
    .typing .dot { animation: blink 1.2s infinite; }
    .typing .dot:nth-child(2) { animation-delay: .2s; }
    .typing .dot:nth-child(3) { animation-delay: .4s; }
    @keyframes blink { 0%, 80%, 100% { opacity:.2 } 40% { opacity: 1 } }
    #spectrum { width:100%; height:160px; background:#0b1022; }
    #states { padding:10px 12px; }
    #composer { display:flex; border-top:1px solid var(--border); }
    #composer input { flex:1; background:#0c1020; color:var(--text); border:none; padding:12px; outline:none; }
    #composer button { background:#0c7bdc; color:#fff; border:none; padding:12px 14px; font-weight:600; cursor:pointer; }
    #composer button:hover { background:#0965b3; }
    code { color: var(--accent); }
    /* Memory panel */
    #memory-list { max-height: 320px; overflow: auto; }
    .mem-item { border-bottom:1px solid var(--border); padding:8px 0; }
    .mem-head { display:flex; gap:8px; align-items:center; font-size:12px; color:var(--muted); margin-bottom:6px; }
    .mem-score { background:#15204a; border:1px solid #22306b; color:#a9b5ea; padding:2px 6px; border-radius:6px; font-weight:600; }
    .mem-text { white-space:pre-wrap; word-wrap:break-word; line-height:1.35; }

    /* Slide-out drawers */
    .drawer { position: fixed; top: 0; right: 0; bottom: 0; width: min(420px, 92vw); background: var(--panel); border-left:1px solid var(--border); transform: translateX(100%); transition: transform .28s ease; z-index: 40; display:flex; flex-direction:column; }
    .drawer.open { transform: translateX(0); }
    .drawer header { display:flex; align-items:center; justify-content:space-between; background:#0c1020; border-bottom:1px solid var(--border); padding:12px; }
    .drawer header h2 { margin:0; font-size:14px; color:var(--muted); }
    .drawer .content { overflow:auto; padding:10px 12px; }
    .drawer .close { background:transparent; border:1px solid var(--border); color:var(--muted); padding:6px 10px; border-radius:8px; cursor:pointer; }
    .drawer .close:hover { color:#fff; border-color:#2a3469; background:#0b132e; }
    .backdrop { position: fixed; inset:0; background: rgba(0,0,0,.4); opacity:0; pointer-events:none; transition: opacity .2s ease; z-index: 30; }
    .backdrop.show { opacity:1; pointer-events:auto; }
    .mqtt-toolbar { display:flex; align-items:center; gap:8px; margin-bottom:10px; font-size:12px; color:var(--muted); }
    .mqtt-toolbar .spacer { flex:1; }
    .mqtt-toolbar button { background:transparent; border:1px solid var(--border); color:var(--muted); padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    .mqtt-toolbar button:hover { color:#fff; border-color:#2a3469; background:#0b132e; }
  #mqtt-log { border:1px solid var(--border); border-radius:10px; background:#0b1020; max-height:70vh; min-height:200px; overflow:auto; padding:0; flex:1; }
    .mqtt-item { border-bottom:1px solid var(--border); padding:10px 12px; }
    .mqtt-item:last-child { border-bottom:none; }
    .mqtt-head { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:6px; font-size:12px; color:var(--muted); }
    .mqtt-topic { color:var(--accent); font-weight:600; word-break:break-word; }
    .mqtt-time { opacity:0.7; }
    .mqtt-payload { margin:0; font-family:"JetBrains Mono", "Fira Code", monospace; font-size:12px; line-height:1.4; background:rgba(90,200,250,0.05); color:var(--text); padding:8px; border-radius:8px; border:1px solid var(--border); white-space:pre-wrap; word-break:break-word; }
    .mqtt-details { margin-top:6px; }
  </style>
  <script>
    let ws;
    let spectrum = new Array(64).fill(0);
    const logEl = () => document.getElementById('log');
    const states = { listening:false, processing:false, llmWriting:false };
    const streamBuffers = new Map(); // id -> { node, text }
    const ttsBuffers = new Map();    // id -> { node, text }
    let lastMemory = { query: '*', k: 25, results: [] };
    const memoryListEl = () => document.getElementById('memory-list');
  const mqttLog = [];
  const MAX_MQTT_LOG_ENTRIES = 200;
  const mqttLogEl = () => document.getElementById('mqtt-log');

    function joinParts(prev, next) {
      const a = (prev || '').trimEnd();
      const b = (next || '').trimStart();
      if (!a) return b;
      if (!b) return a;
      const needSpace = !/[\s]$/.test(a) && !/^[\s.,!?;:]/.test(b);
      return a + (needSpace ? ' ' : '') + b;
    }

    function cloneForLog(value) {
      if (value === undefined || value === null) return value;
      try {
        return typeof structuredClone === 'function' ? structuredClone(value) : JSON.parse(JSON.stringify(value));
      } catch (_) {
        try {
          return JSON.parse(JSON.stringify(value));
        } catch (err) {
          return value;
        }
      }
    }

    function prettifyForLog(value) {
      if (value === undefined) return 'undefined';
      if (value === null) return 'null';
      if (typeof value === 'string') {
        return value.length > 4000 ? value.slice(0, 4000) + "\n… (truncated)" : value;
      }
      try {
        const text = JSON.stringify(value, null, 2);
        return text.length > 4000 ? text.slice(0, 4000) + "\n… (truncated)" : text;
      } catch (_) {
        return String(value);
      }
    }

    function formatTime(ts) {
      const d = new Date(ts);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
    }

    function updateMqttSummary() {
      const el = document.getElementById('mqtt-summary');
      if (!el) return;
      const count = mqttLog.length;
      el.textContent = `${count} message${count === 1 ? '' : 's'}`;
    }

    function renderMqttLog() {
      const container = mqttLogEl();
      if (!container) return;
      container.innerHTML = '';
      const frag = document.createDocumentFragment();
      mqttLog.forEach((entry) => {
        const item = document.createElement('div');
        item.className = 'mqtt-item';

        const head = document.createElement('div');
        head.className = 'mqtt-head';
        const topicEl = document.createElement('div');
        topicEl.className = 'mqtt-topic';
        topicEl.textContent = entry.topic;
        const timeEl = document.createElement('div');
        timeEl.className = 'mqtt-time';
        timeEl.textContent = formatTime(entry.ts);
        head.appendChild(topicEl);
        head.appendChild(timeEl);

        const payloadPre = document.createElement('pre');
        payloadPre.className = 'mqtt-payload';
        payloadPre.textContent = entry.payloadText;

        item.appendChild(head);
        item.appendChild(payloadPre);

        if (entry.envelopeText) {
          const details = document.createElement('details');
          details.className = 'mqtt-details';
          const summary = document.createElement('summary');
          summary.textContent = 'Envelope';
          const pre = document.createElement('pre');
          pre.className = 'mqtt-payload';
          pre.style.marginTop = '6px';
          pre.textContent = entry.envelopeText;
          details.appendChild(summary);
          details.appendChild(pre);
          item.appendChild(details);
        }

        frag.appendChild(item);
      });
      container.appendChild(frag);
      container.scrollTop = container.scrollHeight;
      updateMqttSummary();
    }

    function recordMqttMessage(topic, payload, envelope) {
      const entry = {
        topic: topic || '(unknown)',
        ts: Date.now(),
        payload: cloneForLog(payload),
        envelope: cloneForLog(envelope),
      };
      entry.payloadText = prettifyForLog(entry.payload);
      entry.envelopeText = entry.envelope ? prettifyForLog(entry.envelope) : '';
      mqttLog.push(entry);
      if (mqttLog.length > MAX_MQTT_LOG_ENTRIES) {
        mqttLog.splice(0, mqttLog.length - MAX_MQTT_LOG_ENTRIES);
      }
      const drawer = document.getElementById('drawer-stream');
      if (drawer && drawer.classList.contains('open')) {
        renderMqttLog();
      } else {
        updateMqttSummary();
      }
    }

    function clearMqttLog() {
      mqttLog.length = 0;
      const drawer = document.getElementById('drawer-stream');
      if (drawer && drawer.classList.contains('open')) {
        renderMqttLog();
      } else {
        const container = mqttLogEl();
        if (container) container.innerHTML = '';
        updateMqttSummary();
      }
    }

    function addBubble(role, text, meta='') {
      const row = document.createElement('div');
      row.className = 'row';
      const col = document.createElement('div');
      col.style.display = 'flex';
      col.style.flexDirection = 'column';
      col.style.maxWidth = '72%';
      if (role === 'user') col.style.marginLeft = 'auto';
      const b = document.createElement('div');
      b.className = `bubble ${role}`;
      b.textContent = text;
      col.appendChild(b);
      if (meta) {
        const m = document.createElement('div');
        m.className = 'meta'; m.textContent = meta;
        col.appendChild(m);
      }
      row.appendChild(col);
      logEl().appendChild(row);
      logEl().scrollTop = logEl().scrollHeight;
      return b;
    }

    function setStatus() {
      const s = [];
      if (states.listening) s.push('Listening…');
      if (states.processing) s.push('Processing audio…');
      if (states.llmWriting) s.push('TARS is writing…');
      document.getElementById('status-line').innerHTML = s.length ? `<span class="dot"></span> ${s.join(' • ')}` : 'Idle';
    }

    function connect() {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      ws = new WebSocket(`${proto}://${location.host}/ws`);
      ws.onmessage = (ev) => {
        let msg;
        try {
          msg = JSON.parse(ev.data);
        } catch (_) {
          recordMqttMessage('(parse-error)', { raw: typeof ev.data === 'string' ? ev.data : String(ev.data) });
          return;
        }
        try {
          if (!msg || !msg.topic) {
            recordMqttMessage('(unknown)', msg);
            return;
          }
          const topic = typeof msg.topic === 'string' ? msg.topic : (msg.topic?.value || String(msg.topic));
          const rawPayload = msg.payload;
          recordMqttMessage(topic, rawPayload, msg);
          const p = rawPayload && typeof rawPayload === 'object' ? rawPayload : {};
          if (topic.endsWith('stt/audio_fft')) {
            spectrum = p.fft || [];
            return;
          }
          if (topic.endsWith('stt/partial')) {
            states.listening = true; setStatus();
            updateMicText(p.text || '');
            return;
          }
          if (topic.endsWith('stt/final')) {
            states.listening = false;
            states.processing = true; // audio processed, dispatching to LLM/router
            setStatus();
            updateMicText('');
            if (p.text) addBubble('user', p.text, 'You');
            return;
          }
          if (topic.endsWith('llm/stream')) {
            const id = p.id || 'default';
            const cur = streamBuffers.get(id) || { node: addBubble('tars', '', 'TARS'), text:'' };
            if (p.delta) {
              cur.text += p.delta;
              cur.node.textContent = cur.text;
              streamBuffers.set(id, cur);
            }
            states.llmWriting = !p.done;
            // Once LLM is writing, we are past audio processing step
            states.processing = states.llmWriting ? false : states.processing;
            setStatus();
            return;
          }
          if (topic.endsWith('llm/response')) {
            // Update the existing stream bubble text if present, but don't create new bubbles.
            const id = p.id || 'default';
            const cur = streamBuffers.get(id);
            if (cur && (p.reply || '').trim()) {
              cur.text = (p.reply || '').trim();
              cur.node.textContent = cur.text;
            }
            states.llmWriting = false; setStatus();
            return;
          }
          if (topic.endsWith('tts/say')) {
            const id = p.utt_id || 'default';
            const chunk = (p.text || '').trim();
            if (!chunk) { return; }
            // Ensure we have a target bubble: prefer existing stream bubble node
            let entry = ttsBuffers.get(id);
            if (!entry) {
              let node;
              const stream = streamBuffers.get(id);
              if (stream) {
                node = stream.node;
                stream.text = ''; // reset stream text so TTS controls content
                node.textContent = '';
              } else {
                node = addBubble('tars', '', 'TARS');
              }
              entry = { node, text: '' };
              ttsBuffers.set(id, entry);
            }
            entry.text = joinParts(entry.text, chunk);
            entry.node.textContent = entry.text;
            states.llmWriting = false; setStatus();
            return;
          }
          if (topic.endsWith('tts/status')) {
            // Only update statuses; avoid adding duplicate bubbles here since we render from tts/say
            if ((p.event||'') === 'speaking_start') {
              states.processing = false; states.llmWriting = false; setStatus();
            }
            return;
          }
          if (topic.endsWith('memory/results')) {
            // payload: { query, results: [{document|text, score, ...}], k }
            try {
              lastMemory = {
                query: p.query ?? lastMemory.query ?? '*',
                k: p.k ?? p.top_k ?? lastMemory.k ?? 25,
                results: Array.isArray(p.results) ? p.results : []
              };
              renderMemory(lastMemory);
            } catch (e) { /* ignore */ }
            return;
          }
        } catch(e) { /* ignore downstream handler errors */ }
      };
      ws.onclose = () => setTimeout(connect, 1000);
    }

    function updateMicText(t) {
      document.getElementById('mic-text').textContent = t;
    }

    function drawSpectrum() {
      const canvas = document.getElementById('spectrum');
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.clientWidth; 
      const h = canvas.height = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const n = spectrum.length || 1;
      const barW = w / n;
      for (let i=0;i<n;i++) {
        const v = Math.max(0, Math.min(1, spectrum[i] || 0));
        const bh = v * (h-10);
        const x = i*barW;
        const y = h - bh;
        ctx.fillStyle = `hsl(${(i/n)*240},70%,60%)`;
        ctx.fillRect(x+1, y, Math.max(1, barW-2), bh);
      }
      requestAnimationFrame(drawSpectrum);
    }

    function renderMemory(payload) {
      const list = memoryListEl();
      if (!list) return;
      list.innerHTML = '';
      const q = payload.query ?? '*';
      const k = payload.k ?? 25;
      const results = Array.isArray(payload.results) ? payload.results : [];
      const summary = document.getElementById('mem-summary');
      if (summary) summary.textContent = `${results.length} results for “${q}” (k=${k})`;
      if (!results.length) {
        const empty = document.createElement('div');
        empty.className = 'meta';
        empty.textContent = 'No results';
        list.appendChild(empty);
        return;
      }
      results.forEach((r, idx) => {
        const item = document.createElement('div');
        item.className = 'mem-item';
        const head = document.createElement('div');
        head.className = 'mem-head';
        const ix = document.createElement('div');
        ix.textContent = `#${idx+1}`;
        const score = document.createElement('div');
        score.className = 'mem-score';
        const s = typeof r.score === 'number' ? r.score : (typeof r.similarity === 'number' ? r.similarity : null);
        score.textContent = s != null ? `score ${s.toFixed(3)}` : 'score —';
        head.appendChild(ix);
        head.appendChild(score);
        const text = document.createElement('div');
        text.className = 'mem-text';
        const rawDoc = r.document ?? r.text ?? r.content ?? r.doc ?? null;
        let docText = '';
        let auxLabel = '';
        if (typeof rawDoc === 'string') {
          docText = rawDoc;
        } else if (rawDoc && typeof rawDoc === 'object') {
          // Try common fields from our memory documents
          docText = rawDoc.text ?? rawDoc.content ?? rawDoc.message ?? (rawDoc.document?.text ?? '');
          // Provide a small label if we have topic/source
          const topic = rawDoc.topic || rawDoc.source || '';
          if (topic) auxLabel = String(topic);
        }
        if (!docText) {
          // Last resort: pretty-print JSON (truncated)
          try {
            const pretty = JSON.stringify(rawDoc ?? r, null, 2);
            docText = pretty.length > 2000 ? pretty.slice(0, 2000) + "\n… (truncated)" : pretty;
          } catch (_) {
            docText = String(rawDoc ?? r);
          }
        }
        if (auxLabel) {
          const lbl = document.createElement('div');
          lbl.className = 'meta';
          lbl.textContent = auxLabel;
          item.appendChild(lbl);
        }
        text.textContent = docText;
        item.appendChild(head);
        item.appendChild(text);
        // Collapsible details with full JSON
        try {
          const details = document.createElement('details');
          const summaryEl = document.createElement('summary');
          summaryEl.textContent = 'Details';
          const pre = document.createElement('pre');
          pre.style.margin = '6px 0 0 0';
          pre.style.whiteSpace = 'pre-wrap';
          pre.style.wordBreak = 'break-word';
          pre.textContent = JSON.stringify(r, null, 2);
          details.appendChild(summaryEl);
          details.appendChild(pre);
          item.appendChild(details);
        } catch(_) { /* ignore */ }
        list.appendChild(item);
      });
    }

    async function refreshMemory() {
      const qEl = document.getElementById('mem-query');
      const kEl = document.getElementById('mem-k');
      const q = (qEl?.value || '*').trim() || '*';
      const k = Math.max(1, Math.min(200, parseInt(kEl?.value || '25', 10) || 25));
      const summary = document.getElementById('mem-summary');
      if (summary) summary.textContent = `Querying…`;
      try {
        const res = await fetch(`/api/memory?q=${encodeURIComponent(q)}&k=${k}`);
        const data = await res.json();
        lastMemory = { query: data.query ?? q, k: data.k ?? k, results: data.results ?? [] };
        renderMemory(lastMemory);
      } catch (e) {
        if (summary) summary.textContent = `Error: ${e}`;
      }
    }

    // Drawer controls
    let currentDrawer = null; // 'mic' | 'memory' | 'stream' | null
    function openDrawer(which) {
      if (currentDrawer === which) { return closeDrawer(); }
      closeDrawer(false);
      const el = document.getElementById(`drawer-${which}`);
      if (!el) return;
      el.classList.add('open');
      const bd = document.getElementById('backdrop');
      bd?.classList.add('show');
      currentDrawer = which;
      if (which === 'stream') {
        renderMqttLog();
      }
    }
    function closeDrawer(toggleBackdrop=true) {
      if (currentDrawer) {
        const el = document.getElementById(`drawer-${currentDrawer}`);
        el?.classList.remove('open');
      }
      if (toggleBackdrop) {
        document.getElementById('backdrop')?.classList.remove('show');
      }
      currentDrawer = null;
    }

    window.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape') closeDrawer();
    });

  window.addEventListener('load', ()=>{ connect(); drawSpectrum(); setStatus(); refreshMemory(); updateMqttSummary(); });
  </script>
  </head>
<body>
  <header>
    <h1>TARS Chat</h1>
    <div class="toolbar">
      <button class="btn" onclick="openDrawer('mic')">Microphone</button>
      <button class="btn" onclick="openDrawer('memory')">Memory</button>
      <button class="btn" onclick="openDrawer('stream')">MQTT Stream</button>
    </div>
  </header>
  <div id="container">
    <div id="left">
      <div id="chat" class="panel">
        <div id="log"></div>
        <div id="composer">
          <input id="input" placeholder="Type to add a user message (UI-only demo)…" onkeydown="if(event.key==='Enter'){ if(this.value){ addBubble('user', this.value, 'You'); this.value=''; }}" />
          <button onclick="const i=document.getElementById('input'); if(i.value){ addBubble('user', i.value, 'You'); i.value=''; }">Send</button>
        </div>
      </div>
      <div class="panel">
        <div id="states">
          <div id="status-line" class="status">Idle</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Backdrop for drawers -->
  <div id="backdrop" class="backdrop" onclick="closeDrawer()"></div>

  <!-- Microphone Drawer -->
  <aside id="drawer-mic" class="drawer" aria-hidden="true">
    <header>
      <h2>Microphone</h2>
      <button class="close" onclick="closeDrawer()">Close</button>
    </header>
    <div class="content">
      <div id="mic-text" style="color:var(--muted); min-height:20px; margin-bottom:8px;">&nbsp;</div>
      <canvas id="spectrum"></canvas>
    </div>
  </aside>

  <!-- Memory Drawer -->
  <aside id="drawer-memory" class="drawer" aria-hidden="true">
    <header>
      <h2>Memory</h2>
      <button class="close" onclick="closeDrawer()">Close</button>
    </header>
    <div class="content" style="display:flex; flex-direction:column; gap:8px;">
      <div style="display:flex; gap:8px;">
        <input id="mem-query" placeholder="Query (e.g., *)" value="*" style="flex:1; background:#0c1020; color:var(--text); border:1px solid var(--border); padding:8px; border-radius:6px;" />
        <input id="mem-k" type="number" min="1" max="200" value="25" title="Top-K" style="width:80px; background:#0c1020; color:var(--text); border:1px solid var(--border); padding:8px; border-radius:6px;" />
        <button onclick="refreshMemory()" style="background:#0c7bdc; color:#fff; border:none; padding:8px 10px; font-weight:600; border-radius:6px; cursor:pointer;">Refresh</button>
      </div>
      <div id="mem-summary" class="meta">&nbsp;</div>
      <div id="memory-list" style="border-top:1px solid var(--border); padding-top:10px;"></div>
    </div>
  </aside>

  <!-- MQTT Stream Drawer -->
  <aside id="drawer-stream" class="drawer" aria-hidden="true">
    <header>
      <h2>MQTT Stream</h2>
      <button class="close" onclick="closeDrawer()">Close</button>
    </header>
    <div class="content" style="display:flex; flex-direction:column; gap:10px;">
      <div class="mqtt-toolbar">
        <div id="mqtt-summary">0 messages</div>
        <div class="spacer"></div>
        <button onclick="clearMqttLog()">Clear</button>
      </div>
      <div id="mqtt-log"></div>
    </div>
  </aside>
</body>
</html>