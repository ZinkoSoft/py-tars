<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TARS Chat</title>
  <style>
    :root {
      --bg: #0a0a12; --panel: #0f1324; --border: #1e2545; --text: #e8ecff;
      --tars: #1d2b56; --user: #1d5637; --muted: #9aa4d6; --accent: #5ac8fa;
    }
    * { box-sizing: border-box; }
    body { background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; height:100vh; display:flex; flex-direction:column; }
    header { padding:12px 16px; border-bottom:1px solid var(--border); background:#0c1020; }
    header h1 { margin:0; font-size:16px; color:var(--muted); font-weight:600; }
    #container { display:flex; gap:16px; padding:16px; height:100%; }
    #left { flex:2; display:flex; flex-direction:column; gap:12px; }
    #right { flex:1; display:flex; flex-direction:column; gap:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    #chat { flex:1; display:flex; flex-direction:column; }
    #log { padding:12px; overflow:auto; height:100%; scroll-behavior:smooth; }
    .row { display:flex; margin:8px 0; }
    .bubble { max-width:72%; padding:10px 12px; border-radius:12px; line-height:1.3; }
    .tars { background:var(--tars); border:1px solid #2e3c78; border-top-left-radius:4px; }
    .user { background:var(--user); border:1px solid #2c7a51; margin-left:auto; border-top-right-radius:4px; }
    .meta { font-size:12px; color:var(--muted); margin:6px 2px 0 2px; }
    .status { padding:10px 12px; font-size:13px; color:var(--muted); display:flex; align-items:center; gap:8px; }
    .dot { width:8px; height:8px; border-radius:50%; background:var(--muted); opacity:0.7; }
    .typing { display:inline-flex; gap:4px; align-items:center; }
    .typing .dot { animation: blink 1.2s infinite; }
    .typing .dot:nth-child(2) { animation-delay: .2s; }
    .typing .dot:nth-child(3) { animation-delay: .4s; }
    @keyframes blink { 0%, 80%, 100% { opacity:.2 } 40% { opacity: 1 } }
    #spectrum { width:100%; height:160px; background:#0b1022; }
    #states { padding:10px 12px; }
    #composer { display:flex; border-top:1px solid var(--border); }
    #composer input { flex:1; background:#0c1020; color:var(--text); border:none; padding:12px; outline:none; }
    #composer button { background:#0c7bdc; color:#fff; border:none; padding:12px 14px; font-weight:600; cursor:pointer; }
    #composer button:hover { background:#0965b3; }
    code { color: var(--accent); }
    /* Memory panel */
    #memory-list { max-height: 320px; overflow: auto; }
    .mem-item { border-bottom:1px solid var(--border); padding:8px 0; }
    .mem-head { display:flex; gap:8px; align-items:center; font-size:12px; color:var(--muted); margin-bottom:6px; }
    .mem-score { background:#15204a; border:1px solid #22306b; color:#a9b5ea; padding:2px 6px; border-radius:6px; font-weight:600; }
    .mem-text { white-space:pre-wrap; word-wrap:break-word; line-height:1.35; }
  </style>
  <script>
    let ws;
    let spectrum = new Array(64).fill(0);
    const logEl = () => document.getElementById('log');
  const states = { listening:false, processing:false, llmWriting:false };
    const streamBuffers = new Map(); // id -> { node, text }
    const ttsBuffers = new Map();    // id -> { node, text }
    let lastMemory = { query: '*', k: 25, results: [] };
    const memoryListEl = () => document.getElementById('memory-list');

    function joinParts(prev, next) {
      const a = (prev || '').trimEnd();
      const b = (next || '').trimStart();
      if (!a) return b;
      if (!b) return a;
      const needSpace = !/[\s]$/.test(a) && !/^[\s.,!?;:]/.test(b);
      return a + (needSpace ? ' ' : '') + b;
    }

    function addBubble(role, text, meta='') {
      const row = document.createElement('div');
      row.className = 'row';
      const col = document.createElement('div');
      col.style.display = 'flex';
      col.style.flexDirection = 'column';
      col.style.maxWidth = '72%';
      if (role === 'user') col.style.marginLeft = 'auto';
      const b = document.createElement('div');
      b.className = `bubble ${role}`;
      b.textContent = text;
      col.appendChild(b);
      if (meta) {
        const m = document.createElement('div');
        m.className = 'meta'; m.textContent = meta;
        col.appendChild(m);
      }
      row.appendChild(col);
      logEl().appendChild(row);
      logEl().scrollTop = logEl().scrollHeight;
      return b;
    }

    function setStatus() {
      const s = [];
      if (states.listening) s.push('Listening…');
      if (states.processing) s.push('Processing audio…');
      if (states.llmWriting) s.push('TARS is writing…');
      document.getElementById('status-line').innerHTML = s.length ? `<span class="dot"></span> ${s.join(' • ')}` : 'Idle';
    }

    function connect() {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      ws = new WebSocket(`${proto}://${location.host}/ws`);
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (!msg.topic) return;
          const topic = typeof msg.topic === 'string' ? msg.topic : (msg.topic.value || String(msg.topic));
          const p = msg.payload || {};
          if (topic.endsWith('stt/audio_fft')) {
            spectrum = p.fft || [];
            return;
          }
          if (topic.endsWith('stt/partial')) {
            states.listening = true; setStatus();
            updateMicText(p.text || '');
            return;
          }
          if (topic.endsWith('stt/final')) {
            states.listening = false;
            states.processing = true; // audio processed, dispatching to LLM/router
            setStatus();
            updateMicText('');
            if (p.text) addBubble('user', p.text, 'You');
            return;
          }
          if (topic.endsWith('llm/stream')) {
            const id = p.id || 'default';
            const cur = streamBuffers.get(id) || { node: addBubble('tars', '', 'TARS'), text:'' };
            if (p.delta) {
              cur.text += p.delta;
              cur.node.textContent = cur.text;
              streamBuffers.set(id, cur);
            }
            states.llmWriting = !p.done;
            // Once LLM is writing, we are past audio processing step
            states.processing = states.llmWriting ? false : states.processing;
            setStatus();
            return;
          }
          if (topic.endsWith('llm/response')) {
            // Update the existing stream bubble text if present, but don't create new bubbles.
            const id = p.id || 'default';
            const cur = streamBuffers.get(id);
            if (cur && (p.reply || '').trim()) {
              cur.text = (p.reply || '').trim();
              cur.node.textContent = cur.text;
            }
            states.llmWriting = false; setStatus();
            return;
          }
          if (topic.endsWith('tts/say')) {
            const id = p.utt_id || 'default';
            const chunk = (p.text || '').trim();
            if (!chunk) { return; }
            // Ensure we have a target bubble: prefer existing stream bubble node
            let entry = ttsBuffers.get(id);
            if (!entry) {
              let node;
              const stream = streamBuffers.get(id);
              if (stream) {
                node = stream.node;
                stream.text = ''; // reset stream text so TTS controls content
                node.textContent = '';
              } else {
                node = addBubble('tars', '', 'TARS');
              }
              entry = { node, text: '' };
              ttsBuffers.set(id, entry);
            }
            entry.text = joinParts(entry.text, chunk);
            entry.node.textContent = entry.text;
            states.llmWriting = false; setStatus();
            return;
          }
          if (topic.endsWith('tts/status')) {
            // Only update statuses; avoid adding duplicate bubbles here since we render from tts/say
            if ((p.event||'') === 'speaking_start') {
              states.processing = false; states.llmWriting = false; setStatus();
            }
            return;
          }
          if (topic.endsWith('memory/results')) {
            // payload: { query, results: [{document|text, score, ...}], k }
            try {
              lastMemory = {
                query: p.query ?? lastMemory.query ?? '*',
                k: p.k ?? p.top_k ?? lastMemory.k ?? 25,
                results: Array.isArray(p.results) ? p.results : []
              };
              renderMemory(lastMemory);
            } catch (e) { /* ignore */ }
            return;
          }
        } catch(e) { /* ignore parse errors */ }
      };
      ws.onclose = () => setTimeout(connect, 1000);
    }

    function updateMicText(t) {
      document.getElementById('mic-text').textContent = t;
    }

    function drawSpectrum() {
      const canvas = document.getElementById('spectrum');
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.clientWidth; 
      const h = canvas.height = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const n = spectrum.length || 1;
      const barW = w / n;
      for (let i=0;i<n;i++) {
        const v = Math.max(0, Math.min(1, spectrum[i] || 0));
        const bh = v * (h-10);
        const x = i*barW;
        const y = h - bh;
        ctx.fillStyle = `hsl(${(i/n)*240},70%,60%)`;
        ctx.fillRect(x+1, y, Math.max(1, barW-2), bh);
      }
      requestAnimationFrame(drawSpectrum);
    }

    function renderMemory(payload) {
      const list = memoryListEl();
      if (!list) return;
      list.innerHTML = '';
      const q = payload.query ?? '*';
      const k = payload.k ?? 25;
      const results = Array.isArray(payload.results) ? payload.results : [];
      const summary = document.getElementById('mem-summary');
      if (summary) summary.textContent = `${results.length} results for “${q}” (k=${k})`;
      if (!results.length) {
        const empty = document.createElement('div');
        empty.className = 'meta';
        empty.textContent = 'No results';
        list.appendChild(empty);
        return;
      }
      results.forEach((r, idx) => {
        const item = document.createElement('div');
        item.className = 'mem-item';
        const head = document.createElement('div');
        head.className = 'mem-head';
        const ix = document.createElement('div');
        ix.textContent = `#${idx+1}`;
        const score = document.createElement('div');
        score.className = 'mem-score';
        const s = typeof r.score === 'number' ? r.score : (typeof r.similarity === 'number' ? r.similarity : null);
        score.textContent = s != null ? `score ${s.toFixed(3)}` : 'score —';
        head.appendChild(ix);
        head.appendChild(score);
        const text = document.createElement('div');
        text.className = 'mem-text';
        const rawDoc = r.document ?? r.text ?? r.content ?? r.doc ?? null;
        let docText = '';
        let auxLabel = '';
        if (typeof rawDoc === 'string') {
          docText = rawDoc;
        } else if (rawDoc && typeof rawDoc === 'object') {
          // Try common fields from our memory documents
          docText = rawDoc.text ?? rawDoc.content ?? rawDoc.message ?? (rawDoc.document?.text ?? '');
          // Provide a small label if we have topic/source
          const topic = rawDoc.topic || rawDoc.source || '';
          if (topic) auxLabel = String(topic);
        }
        if (!docText) {
          // Last resort: pretty-print JSON (truncated)
          try {
            const pretty = JSON.stringify(rawDoc ?? r, null, 2);
            docText = pretty.length > 2000 ? pretty.slice(0, 2000) + "\n… (truncated)" : pretty;
          } catch (_) {
            docText = String(rawDoc ?? r);
          }
        }
        if (auxLabel) {
          const lbl = document.createElement('div');
          lbl.className = 'meta';
          lbl.textContent = auxLabel;
          item.appendChild(lbl);
        }
        text.textContent = docText;
        item.appendChild(head);
        item.appendChild(text);
        // Collapsible details with full JSON
        try {
          const details = document.createElement('details');
          const summaryEl = document.createElement('summary');
          summaryEl.textContent = 'Details';
          const pre = document.createElement('pre');
          pre.style.margin = '6px 0 0 0';
          pre.style.whiteSpace = 'pre-wrap';
          pre.style.wordBreak = 'break-word';
          pre.textContent = JSON.stringify(r, null, 2);
          details.appendChild(summaryEl);
          details.appendChild(pre);
          item.appendChild(details);
        } catch(_) { /* ignore */ }
        list.appendChild(item);
      });
    }

    async function refreshMemory() {
      const qEl = document.getElementById('mem-query');
      const kEl = document.getElementById('mem-k');
      const q = (qEl?.value || '*').trim() || '*';
      const k = Math.max(1, Math.min(200, parseInt(kEl?.value || '25', 10) || 25));
      const summary = document.getElementById('mem-summary');
      if (summary) summary.textContent = `Querying…`;
      try {
        const res = await fetch(`/api/memory?q=${encodeURIComponent(q)}&k=${k}`);
        const data = await res.json();
        lastMemory = { query: data.query ?? q, k: data.k ?? k, results: data.results ?? [] };
        renderMemory(lastMemory);
      } catch (e) {
        if (summary) summary.textContent = `Error: ${e}`;
      }
    }

    window.addEventListener('load', ()=>{ connect(); drawSpectrum(); setStatus(); refreshMemory(); });
  </script>
  </head>
<body>
  <header>
    <h1>TARS Chat</h1>
  </header>
  <div id="container">
    <div id="left">
      <div id="chat" class="panel">
        <div id="log"></div>
        <div id="composer">
          <input id="input" placeholder="Type to add a user message (UI-only demo)…" onkeydown="if(event.key==='Enter'){ if(this.value){ addBubble('user', this.value, 'You'); this.value=''; }}" />
          <button onclick="const i=document.getElementById('input'); if(i.value){ addBubble('user', i.value, 'You'); i.value=''; }">Send</button>
        </div>
      </div>
      <div class="panel">
        <div id="states">
          <div id="status-line" class="status">Idle</div>
        </div>
      </div>
    </div>
    <div id="right">
      <div class="panel">
        <div class="status" style="border-bottom:1px solid var(--border);">Microphone</div>
        <div style="padding:10px 12px;">
          <div id="mic-text" style="color:var(--muted); min-height:20px;">&nbsp;</div>
        </div>
        <canvas id="spectrum"></canvas>
      </div>
      <div class="panel">
        <div class="status" style="border-bottom:1px solid var(--border);">Memory</div>
        <div style="padding:10px 12px; display:flex; flex-direction:column; gap:8px;">
          <div style="display:flex; gap:8px;">
            <input id="mem-query" placeholder="Query (e.g., *)" value="*" style="flex:1; background:#0c1020; color:var(--text); border:1px solid var(--border); padding:8px; border-radius:6px;" />
            <input id="mem-k" type="number" min="1" max="200" value="25" title="Top-K" style="width:80px; background:#0c1020; color:var(--text); border:1px solid var(--border); padding:8px; border-radius:6px;" />
            <button onclick="refreshMemory()" style="background:#0c7bdc; color:#fff; border:none; padding:8px 10px; font-weight:600; border-radius:6px; cursor:pointer;">Refresh</button>
          </div>
          <div id="mem-summary" class="meta">&nbsp;</div>
        </div>
        <div id="memory-list" style="padding:10px 12px; border-top:1px solid var(--border);"></div>
      </div>
    </div>
  </div>
</body>
</html>