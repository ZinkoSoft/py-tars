<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TARS Chat</title>
  <style>
    :root {
      --bg: #0a0a12; --panel: #0f1324; --border: #1e2545; --text: #e8ecff;
      --tars: #1d2b56; --user: #1d5637; --muted: #9aa4d6; --accent: #5ac8fa;
    }
    * { box-sizing: border-box; }
    body { background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; height:100vh; display:flex; flex-direction:column; }
    header { padding:12px 16px; border-bottom:1px solid var(--border); background:#0c1020; display:flex; align-items:center; justify-content:space-between; gap:12px; }
    header h1 { margin:0; font-size:16px; color:var(--muted); font-weight:600; }
    .toolbar { display:flex; gap:8px; }
    .btn { background:transparent; color:var(--muted); border:1px solid var(--border); padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    .btn:hover { color:#fff; border-color:#2a3469; background:#0b132e; }
    .btn.health { position:relative; }
    .health-indicator { 
      display: inline-block;
      width: 8px; 
      height: 8px; 
      border-radius: 50%; 
      background: #f44336; 
      margin-left: 6px;
      vertical-align: middle;
    }
    #container { display:flex; gap:16px; padding:16px; height:100%; }
    #left { flex:1; display:flex; flex-direction:column; gap:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    #chat { flex:1; display:flex; flex-direction:column; }
    #log { padding:12px; overflow:auto; height:100%; scroll-behavior:smooth; }
    .row { display:flex; margin:8px 0; }
    .bubble { max-width:72%; padding:10px 12px; border-radius:12px; line-height:1.3; }
    .tars { background:var(--tars); border:1px solid #2e3c78; border-top-left-radius:4px; }
    .user { background:var(--user); border:1px solid #2c7a51; margin-left:auto; border-top-right-radius:4px; }
    .meta { font-size:12px; color:var(--muted); margin:6px 2px 0 2px; }
    .status { padding:10px 12px; font-size:13px; color:var(--muted); display:flex; align-items:center; gap:8px; }
    .dot { width:8px; height:8px; border-radius:50%; background:var(--muted); opacity:0.7; }
    .typing { display:inline-flex; gap:4px; align-items:center; }
    .typing .dot { animation: blink 1.2s infinite; }
    .typing .dot:nth-child(2) { animation-delay: .2s; }
    .typing .dot:nth-child(3) { animation-delay: .4s; }
    @keyframes blink { 0%, 80%, 100% { opacity:.2 } 40% { opacity: 1 } }
    #spectrum { width:100%; height:160px; background:#0b1022; }
    #states { padding:10px 12px; }
    #composer { display:flex; border-top:1px solid var(--border); }
    #composer input { flex:1; background:#0c1020; color:var(--text); border:none; padding:12px; outline:none; }
    #composer button { background:#0c7bdc; color:#fff; border:none; padding:12px 14px; font-weight:600; cursor:pointer; }
    #composer button:hover { background:#0965b3; }
    code { color: var(--accent); }
    /* Memory panel */
    #memory-list { max-height: 320px; overflow: auto; }
    .mem-item { border-bottom:1px solid var(--border); padding:8px 0; }
    .mem-head { display:flex; gap:8px; align-items:center; font-size:12px; color:var(--muted); margin-bottom:6px; }
    .mem-score { background:#15204a; border:1px solid #22306b; color:#a9b5ea; padding:2px 6px; border-radius:6px; font-weight:600; }
    .mem-text { white-space:pre-wrap; word-wrap:break-word; line-height:1.35; }

    /* Slide-out drawers */
    .drawer { position: fixed; top: 0; right: 0; bottom: 0; width: min(420px, 92vw); background: var(--panel); border-left:1px solid var(--border); transform: translateX(100%); transition: transform .28s ease; z-index: 40; display:flex; flex-direction:column; }
    .drawer.open { transform: translateX(0); }
    .drawer header { display:flex; align-items:center; justify-content:space-between; background:#0c1020; border-bottom:1px solid var(--border); padding:12px; }
    .drawer header h2 { margin:0; font-size:14px; color:var(--muted); }
    .drawer .content { overflow:auto; padding:10px 12px; }
    .drawer .close { background:transparent; border:1px solid var(--border); color:var(--muted); padding:6px 10px; border-radius:8px; cursor:pointer; }
    .drawer .close:hover { color:#fff; border-color:#2a3469; background:#0b132e; }
    .backdrop { position: fixed; inset:0; background: rgba(0,0,0,.4); opacity:0; pointer-events:none; transition: opacity .2s ease; z-index: 30; }
    .backdrop.show { opacity:1; pointer-events:auto; }
    .mqtt-toolbar { display:flex; align-items:center; gap:8px; margin-bottom:10px; font-size:12px; color:var(--muted); }
    .mqtt-toolbar .spacer { flex:1; }
    .mqtt-toolbar button { background:transparent; border:1px solid var(--border); color:var(--muted); padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    .mqtt-toolbar button:hover { color:#fff; border-color:#2a3469; background:#0b132e; }
    #mqtt-log { border:1px solid var(--border); border-radius:10px; background:#0b1020; max-height:70vh; min-height:200px; overflow:auto; padding:0; flex:1; }
    .mqtt-item { border-bottom:1px solid var(--border); padding:10px 12px; }
    .mqtt-item:last-child { border-bottom:none; }
    .mqtt-head { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:6px; font-size:12px; color:var(--muted); }
    .mqtt-topic { color:var(--accent); font-weight:600; word-break:break-word; }
    .mqtt-time { opacity:0.7; }
    .mqtt-payload { margin:0; font-family:"JetBrains Mono", "Fira Code", monospace; font-size:12px; line-height:1.4; background:rgba(90,200,250,0.05); color:var(--text); padding:8px; border-radius:8px; border:1px solid var(--border); white-space:pre-wrap; word-break:break-word; }
    .mqtt-details { margin-top:6px; }
  </style>
  <script>
    let ws;
    let spectrum = new Array(64).fill(0);
    const logEl = () => document.getElementById('log');
    const states = { listening:false, processing:false, llmWriting:false };
    const assistantMessages = new Map(); // id -> { node, text, lastSeq, ttsChunks }
    let lastMemory = { query: '*', k: 25, results: [] };
    const memoryListEl = () => document.getElementById('memory-list');
    const mqttLog = [];
    const MAX_MQTT_LOG_ENTRIES = 200;
    const mqttLogEl = () => document.getElementById('mqtt-log');
    let esp32Health = { ok: false, event: 'unknown', timestamp: null };
    const healthComponents = {
      'esp32': { name: 'ESP32 Movement', ok: false, lastPing: null, error: null },
      'stt': { name: 'Speech-to-Text', ok: false, lastPing: null, error: null },
      'llm': { name: 'Language Model', ok: false, lastPing: null, error: null },
      'tts': { name: 'Text-to-Speech', ok: false, lastPing: null, error: null },
      'memory': { name: 'Memory Service', ok: false, lastPing: null, error: null },
      'camera': { name: 'Camera Service', ok: false, lastPing: null, error: null },
      'router': { name: 'Message Router', ok: false, lastPing: null, error: null },
      'mcp-bridge': { name: 'MCP Bridge', ok: false, lastPing: null, error: null }
    };
    const HEALTH_TIMEOUT_MS = 30000; // 30 seconds

    function joinParts(prev, next) {
      const a = (prev || '').trimEnd();
      const b = (next || '').trimStart();
      if (!a) return b;
      if (!b) return a;
      const needSpace = !(/[\s]$/.test(a) || /^[\s.,!?;:]/.test(b));
      return a + (needSpace ? ' ' : '') + b;
    }

    function ensureAssistantEntry(id, { meta = 'TARS', reset = false } = {}) {
      const key = id || 'default';
      let entry = assistantMessages.get(key);
      if (!entry) {
        const node = addBubble('tars', '', meta);
        entry = { node, text: '', lastSeq: 0, ttsChunks: 0 };
        assistantMessages.set(key, entry);
      }
      if (reset) {
        entry.text = '';
        entry.node.textContent = '';
        entry.lastSeq = 0;
        entry.ttsChunks = 0;
      }
      return entry;
    }

    function setAssistantText(id, text, opts = {}) {
      const entry = ensureAssistantEntry(id, opts);
      entry.text = text || '';
      entry.node.textContent = entry.text;
      entry.ttsChunks = 0;
    }

    function cloneForLog(value) {
      if (value === undefined || value === null) return value;
      try {
        return typeof structuredClone === 'function' ? structuredClone(value) : JSON.parse(JSON.stringify(value));
      } catch (_) {
        try {
          return JSON.parse(JSON.stringify(value));
        } catch (err) {
          return value;
        }
      }
    }

    function prettifyForLog(value) {
      if (value === undefined) return 'undefined';
      if (value === null) return 'null';
      if (typeof value === 'string') {
        return value.length > 4000 ? value.slice(0, 4000) + "\n… (truncated)" : value;
      }
      try {
        const text = JSON.stringify(value, null, 2);
        return text.length > 4000 ? text.slice(0, 4000) + "\n… (truncated)" : text;
      } catch (_) {
        return String(value);
      }
    }

    function formatTime(ts) {
      const d = new Date(ts);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
    }

    function updateMqttSummary() {
      const el = document.getElementById('mqtt-summary');
      if (!el) return;
      const count = mqttLog.length;
      el.textContent = `${count} message${count === 1 ? '' : 's'}`;
    }

    function renderMqttLog() {
      const container = mqttLogEl();
      if (!container) return;
      container.innerHTML = '';
      const frag = document.createDocumentFragment();
      mqttLog.forEach((entry) => {
        const item = document.createElement('div');
        item.className = 'mqtt-item';

        const head = document.createElement('div');
        head.className = 'mqtt-head';
        const topicEl = document.createElement('div');
        topicEl.className = 'mqtt-topic';
        topicEl.textContent = entry.topic;
        const timeEl = document.createElement('div');
        timeEl.className = 'mqtt-time';
        timeEl.textContent = formatTime(entry.ts);
        head.appendChild(topicEl);
        head.appendChild(timeEl);

        const payloadPre = document.createElement('pre');
        payloadPre.className = 'mqtt-payload';
        payloadPre.textContent = entry.payloadText;

        item.appendChild(head);
        item.appendChild(payloadPre);

        if (entry.envelopeText) {
          const details = document.createElement('details');
          details.className = 'mqtt-details';
          const summary = document.createElement('summary');
          summary.textContent = 'Envelope';
          const pre = document.createElement('pre');
          pre.className = 'mqtt-payload';
          pre.style.marginTop = '6px';
          pre.textContent = entry.envelopeText;
          details.appendChild(summary);
          details.appendChild(pre);
          item.appendChild(details);
        }

        frag.appendChild(item);
      });
      container.appendChild(frag);
      container.scrollTop = container.scrollHeight;
      updateMqttSummary();
    }

    function recordMqttMessage(topic, payload, envelope) {
      const entry = {
        topic: topic || '(unknown)',
        ts: Date.now(),
        payload: cloneForLog(payload),
        envelope: cloneForLog(envelope),
      };
      entry.payloadText = prettifyForLog(entry.payload);
      entry.envelopeText = entry.envelope ? prettifyForLog(entry.envelope) : '';
      mqttLog.push(entry);
      if (mqttLog.length > MAX_MQTT_LOG_ENTRIES) {
        mqttLog.splice(0, mqttLog.length - MAX_MQTT_LOG_ENTRIES);
      }
      const drawer = document.getElementById('drawer-stream');
      if (drawer && drawer.classList.contains('open')) {
        renderMqttLog();
      } else {
        updateMqttSummary();
      }
    }

    function clearMqttLog() {
      mqttLog.length = 0;
      const drawer = document.getElementById('drawer-stream');
      if (drawer && drawer.classList.contains('open')) {
        renderMqttLog();
      } else {
        const container = mqttLogEl();
        if (container) container.innerHTML = '';
        updateMqttSummary();
      }
    }

    function addBubble(role, text, meta='') {
      const row = document.createElement('div');
      row.className = 'row';
      const col = document.createElement('div');
      col.style.display = 'flex';
      col.style.flexDirection = 'column';
      col.style.maxWidth = '72%';
      if (role === 'user') col.style.marginLeft = 'auto';
      const b = document.createElement('div');
      b.className = `bubble ${role}`;
      b.textContent = text;
      col.appendChild(b);
      if (meta) {
        const m = document.createElement('div');
        m.className = 'meta'; m.textContent = meta;
        col.appendChild(m);
      }
      row.appendChild(col);
      logEl().appendChild(row);
      logEl().scrollTop = logEl().scrollHeight;
      return b;
    }

    function setStatus() {
      const s = [];
      if (states.listening) s.push('Listening…');
      if (states.processing) s.push('Processing audio…');
      if (states.llmWriting) s.push('TARS is writing…');
      // Add ESP32 status
      const esp32Status = esp32Health.ok ? 'ESP32 OK' : 'ESP32 Offline';
      if (esp32Health.event && esp32Health.event !== 'ready') {
        s.push(`${esp32Status} (${esp32Health.event})`);
      } else {
        s.push(esp32Status);
      }
      const statusText = s.length ? `${s.join(' • ')}` : 'Idle';
      const statusEl = document.getElementById('status-line');
      statusEl.innerHTML = `<span class="dot"></span> ${statusText}`;
      // Color the dot based on ESP32 health
      const dot = statusEl.querySelector('.dot');
      if (dot) {
        dot.style.background = esp32Health.ok ? '#4caf50' : '#f44336'; // green or red
      }
    }

    function updateEsp32Status() {
      setStatus(); // Refresh the status line
      updateHealthStatus('esp32', esp32Health.ok, esp32Health.event);
      updateHealthButton();
    }

    function updateHealthStatus(component, ok, event = null, error = null) {
      const comp = healthComponents[component];
      if (!comp) return;
      
      comp.ok = ok;
      comp.lastPing = Date.now();
      comp.error = error || (ok ? null : event);
      
      updateHealthButton();
      
      // Update the health panel if it's currently open
      if (currentDrawer === 'health') {
        renderHealthPanel();
      }
    }

    function checkHealthTimeouts() {
      const now = Date.now();
      let hasOffline = false;
      
      Object.keys(healthComponents).forEach(key => {
        const comp = healthComponents[key];
        if (comp.lastPing && (now - comp.lastPing) > HEALTH_TIMEOUT_MS) {
          if (comp.ok) {
            comp.ok = false;
            comp.error = 'timeout';
            hasOffline = true;
          }
        }
        if (!comp.ok) hasOffline = true;
      });
      
      if (hasOffline) {
        updateHealthButton();
        // Update the health panel if it's currently open
        if (currentDrawer === 'health') {
          renderHealthPanel();
        }
      }
    }

    function updateHealthButton() {
      const indicator = document.querySelector('.health-indicator');
      if (!indicator) return;
      
      const allOk = Object.values(healthComponents).every(comp => comp.ok);
      indicator.style.background = allOk ? '#4caf50' : '#f44336';
      
      // Update title with summary
      const okCount = Object.values(healthComponents).filter(comp => comp.ok).length;
      const totalCount = Object.keys(healthComponents).length;
      const btn = document.querySelector('.btn.health');
      if (btn) {
        btn.title = `System Health: ${okCount}/${totalCount} components online`;
      }
    }

    function connect() {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      ws = new WebSocket(`${proto}://${location.host}/ws`);
      ws.onmessage = (ev) => {
        let msg;
        try {
          msg = JSON.parse(ev.data);
        } catch (_) {
          recordMqttMessage('(parse-error)', { raw: typeof ev.data === 'string' ? ev.data : String(ev.data) });
          return;
        }
        try {
          if (!msg || !msg.topic) {
            recordMqttMessage('(unknown)', msg);
            return;
          }
          const topic = typeof msg.topic === 'string' ? msg.topic : (msg.topic?.value || String(msg.topic));
          const rawPayload = msg.payload;
          recordMqttMessage(topic, rawPayload, msg);
          const p = rawPayload && typeof rawPayload === 'object' ? rawPayload : {};
          if (topic.endsWith('stt/audio_fft')) {
            spectrum = p.fft || [];
            return;
          }
          if (topic.endsWith('stt/partial')) {
            states.listening = true; setStatus();
            updateMicText(p.text || '');
            updateHealthStatus('stt', true, 'active');
            return;
          }
          if (topic.endsWith('stt/final')) {
            states.listening = false;
            states.processing = true; // audio processed, dispatching to LLM/router
            setStatus();
            updateMicText('');
            if (p.text) addBubble('user', p.text, 'You');
            updateHealthStatus('stt', true, 'processed');
            return;
          }
          if (topic.endsWith('llm/stream')) {
            const data = p.data || p;
            const id = data.id || 'default';
            const seq = typeof data.seq === 'number' ? data.seq : (data.seq != null ? Number(data.seq) : null);
            const entry = ensureAssistantEntry(id, { meta: 'TARS', reset: seq !== null && seq <= 1 });
            if (data.delta) {
              entry.text = entry.text ? entry.text + data.delta : data.delta;
              entry.node.textContent = entry.text;
            }
            if (seq !== null) {
              entry.lastSeq = seq;
            }
            entry.ttsChunks = 0;
            states.llmWriting = !data.done;
            states.processing = false;
            setStatus();
            updateHealthStatus('llm', true, 'streaming');
            return;
          }
          if (topic.endsWith('llm/response')) {
            const data = p.data || p;
            const id = data.id || 'default';
            const finalText = (data.reply || '').trim();
            if (finalText) {
              setAssistantText(id, finalText, { meta: 'TARS' });
            }
            states.llmWriting = false;
            states.processing = false;
            setStatus();
            updateHealthStatus('llm', true, 'completed');
            return;
          }
          if (topic.endsWith('tts/say')) {
            // Audio playback notifications duplicate the spoken text; avoid rewriting the chat bubble
            // unless this utterance has no associated LLM stream (wake acknowledgements, system prompts, etc.).
            const id = p.utt_id || 'default';
            const chunk = (p.text || '').trim();
            if (chunk) {
              const entry = ensureAssistantEntry(id, { meta: p.wake_ack ? 'TARS' : 'TARS' });
              if (!entry.lastSeq) {
                entry.ttsChunks = (entry.ttsChunks || 0) + 1;
                entry.text = entry.ttsChunks === 1 ? chunk : joinParts(entry.text, chunk);
                entry.node.textContent = entry.text;
              }
            }
            states.llmWriting = false;
            states.processing = false;
            setStatus();
            updateHealthStatus('tts', true, 'speaking');
            return;
          }
          if (topic.endsWith('tts/status')) {
            // Only update statuses; avoid adding duplicate bubbles here since we render from tts/say
            if ((p.event||'') === 'speaking_start') {
              states.processing = false; states.llmWriting = false; setStatus();
              updateHealthStatus('tts', true, 'speaking');
            }
            return;
          }
          if (topic.endsWith('memory/results')) {
            // payload: { query, results: [{document|text, score, ...}], k }
            try {
              lastMemory = {
                query: p.query ?? lastMemory.query ?? '*',
                k: p.k ?? p.top_k ?? lastMemory.k ?? 25,
                results: Array.isArray(p.results) ? p.results : []
              };
              renderMemory(lastMemory);
              updateHealthStatus('memory', true, 'query_completed');
            } catch (e) { /* ignore */ }
            return;
          }
          if (topic.startsWith('system/health/')) {
            // Health status: { ok, event, timestamp }
            try {
              // Extract data from envelope (handles both wrapped and unwrapped formats)
              const healthData = p.data || p;
              const component = topic.split('/').pop(); // Extract component name from topic
              const ok = typeof healthData.ok === 'boolean' ? healthData.ok : false;
              const event = healthData.event || healthData.err || 'unknown';
              const error = healthData.err || null;
              
              console.log(`[Health] ${component}: ok=${ok}, event=${event}`, healthData);
              
              if (component === 'movement-esp32') {
                esp32Health = { ok, event, timestamp: healthData.timestamp || null };
                updateEsp32Status();
              } else {
                // Map topic component to our health components
                const componentMap = {
                  'stt': 'stt',
                  'llm': 'llm', 
                  'tts': 'tts',
                  'memory': 'memory',
                  'camera': 'camera',
                  'router': 'router',
                  'mcp-bridge': 'mcp-bridge',
                  'movement-service': 'esp32'  // movement-service also maps to esp32
                };
                const healthKey = componentMap[component];
                if (healthKey) {
                  updateHealthStatus(healthKey, ok, event, error);
                } else {
                  console.warn(`[Health] Unknown component: ${component}`);
                }
              }
            } catch (e) { 
              console.error('[Health] Error processing health message:', e, 'payload:', p);
            }
            return;
          }
          // Camera frames now handled via MJPEG over HTTP, not MQTT
        } catch(e) { /* ignore downstream handler errors */ }
      };
      ws.onclose = () => setTimeout(connect, 1000);
    }

    function updateMicText(t) {
      document.getElementById('mic-text').textContent = t;
    }

    function drawSpectrum() {
      const canvas = document.getElementById('spectrum');
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.clientWidth; 
      const h = canvas.height = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const n = spectrum.length || 1;
      const barW = w / n;
      for (let i=0;i<n;i++) {
        const v = Math.max(0, Math.min(1, spectrum[i] || 0));
        const bh = v * (h-10);
        const x = i*barW;
        const y = h - bh;
        ctx.fillStyle = `hsl(${(i/n)*240},70%,60%)`;
        ctx.fillRect(x+1, y, Math.max(1, barW-2), bh);
      }
      requestAnimationFrame(drawSpectrum);
    }

    function renderMemory(payload) {
      const list = memoryListEl();
      if (!list) return;
      list.innerHTML = '';
      const q = payload.query ?? '*';
      const k = payload.k ?? 25;
      const results = Array.isArray(payload.results) ? payload.results : [];
      const summary = document.getElementById('mem-summary');
      if (summary) summary.textContent = `${results.length} results for “${q}” (k=${k})`;
      if (!results.length) {
        const empty = document.createElement('div');
        empty.className = 'meta';
        empty.textContent = 'No results';
        list.appendChild(empty);
        return;
      }
      results.forEach((r, idx) => {
        const item = document.createElement('div');
        item.className = 'mem-item';
        const head = document.createElement('div');
        head.className = 'mem-head';
        const ix = document.createElement('div');
        ix.textContent = `#${idx+1}`;
        const score = document.createElement('div');
        score.className = 'mem-score';
        const s = typeof r.score === 'number' ? r.score : (typeof r.similarity === 'number' ? r.similarity : null);
        score.textContent = s != null ? `score ${s.toFixed(3)}` : 'score —';
        head.appendChild(ix);
        head.appendChild(score);
        const text = document.createElement('div');
        text.className = 'mem-text';
        const rawDoc = r.document ?? r.text ?? r.content ?? r.doc ?? null;
        let docText = '';
        let auxLabel = '';
        if (typeof rawDoc === 'string') {
          docText = rawDoc;
        } else if (rawDoc && typeof rawDoc === 'object') {
          // Try common fields from our memory documents
          docText = rawDoc.text ?? rawDoc.content ?? rawDoc.message ?? (rawDoc.document?.text ?? '');
          // Provide a small label if we have topic/source
          const topic = rawDoc.topic || rawDoc.source || '';
          if (topic) auxLabel = String(topic);
        }
        if (!docText) {
          // Last resort: pretty-print JSON (truncated)
          try {
            const pretty = JSON.stringify(rawDoc ?? r, null, 2);
            docText = pretty.length > 2000 ? pretty.slice(0, 2000) + "\n… (truncated)" : pretty;
          } catch (_) {
            docText = String(rawDoc ?? r);
          }
        }
        if (auxLabel) {
          const lbl = document.createElement('div');
          lbl.className = 'meta';
          lbl.textContent = auxLabel;
          item.appendChild(lbl);
        }
        text.textContent = docText;
        item.appendChild(head);
        item.appendChild(text);
        // Collapsible details with full JSON
        try {
          const details = document.createElement('details');
          const summaryEl = document.createElement('summary');
          summaryEl.textContent = 'Details';
          const pre = document.createElement('pre');
          pre.style.margin = '6px 0 0 0';
          pre.style.whiteSpace = 'pre-wrap';
          pre.style.wordBreak = 'break-word';
          pre.textContent = JSON.stringify(r, null, 2);
          details.appendChild(summaryEl);
          details.appendChild(pre);
          item.appendChild(details);
        } catch(_) { /* ignore */ }
        list.appendChild(item);
      });
    }

    async function refreshMemory() {
      const qEl = document.getElementById('mem-query');
      const kEl = document.getElementById('mem-k');
      const q = (qEl?.value || '*').trim() || '*';
      const k = Math.max(1, Math.min(200, parseInt(kEl?.value || '25', 10) || 25));
      const summary = document.getElementById('mem-summary');
      if (summary) summary.textContent = `Querying…`;
      try {
        const res = await fetch(`/api/memory?q=${encodeURIComponent(q)}&k=${k}`);
        const data = await res.json();
        lastMemory = { query: data.query ?? q, k: data.k ?? k, results: data.results ?? [] };
        renderMemory(lastMemory);
      } catch (e) {
        if (summary) summary.textContent = `Error: ${e}`;
      }
    }

    function renderHealthPanel() {
      const container = document.getElementById('health-components');
      if (!container) return;
      
      const overallEl = document.getElementById('overall-health');
      const okCount = Object.values(healthComponents).filter(comp => comp.ok).length;
      const totalCount = Object.keys(healthComponents).length;
      
      if (overallEl) {
        overallEl.textContent = `${okCount}/${totalCount} components online`;
        overallEl.style.color = okCount === totalCount ? '#4caf50' : okCount === 0 ? '#f44336' : '#ff9800';
      }
      
      container.innerHTML = '';
      
      Object.entries(healthComponents).forEach(([key, comp]) => {
        const item = document.createElement('div');
        item.className = 'health-item';
        item.style.cssText = `
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 8px 12px;
          margin: 4px 0;
          border-radius: 6px;
          background: ${comp.ok ? 'rgba(76, 175, 80, 0.1)' : 'rgba(244, 67, 54, 0.1)'};
          border: 1px solid ${comp.ok ? '#4caf50' : '#f44336'};
        `;
        
        const left = document.createElement('div');
        left.style.cssText = 'display: flex; align-items: center; gap: 8px;';
        
        const indicator = document.createElement('div');
        indicator.style.cssText = `
          width: 12px;
          height: 12px;
          border-radius: 50%;
          background: ${comp.ok ? '#4caf50' : '#f44336'};
          flex-shrink: 0;
        `;
        
        const name = document.createElement('div');
        name.style.cssText = 'font-weight: 600; color: var(--text);';
        name.textContent = comp.name;
        
        left.appendChild(indicator);
        left.appendChild(name);
        
        const right = document.createElement('div');
        right.style.cssText = 'font-size: 12px; color: var(--muted); text-align: right;';
        
        if (comp.lastPing) {
          const timeAgo = Math.floor((Date.now() - comp.lastPing) / 1000);
          const timeStr = timeAgo < 60 ? `${timeAgo}s ago` : `${Math.floor(timeAgo/60)}m ago`;
          right.textContent = timeStr;
          
          // Add hover tooltip with more details
          item.title = `Last ping: ${formatTime(comp.lastPing)}\nStatus: ${comp.ok ? 'Online' : 'Offline'}${comp.error ? `\nError: ${comp.error}` : ''}`;
        } else {
          right.textContent = 'Never';
          item.title = 'No ping received yet';
        }
        
        item.appendChild(left);
        item.appendChild(right);
        container.appendChild(item);
      });
    }
    let currentDrawer = null; // 'mic' | 'memory' | 'stream' | 'camera' | 'health' | null
    function openDrawer(which) {
      if (currentDrawer === which) { return closeDrawer(); }
      closeDrawer(false);
      const el = document.getElementById(`drawer-${which}`);
      if (!el) return;
      el.classList.add('open');
      const bd = document.getElementById('backdrop');
      bd?.classList.add('show');
      currentDrawer = which;
      if (which === 'stream') {
        renderMqttLog();
      } else if (which === 'camera') {
        startCameraStream();
      } else if (which === 'health') {
        renderHealthPanel();
      }
    }
    function closeDrawer(toggleBackdrop=true) {
      if (currentDrawer) {
        const el = document.getElementById(`drawer-${currentDrawer}`);
        el?.classList.remove('open');
        // Stop camera stream when closing camera drawer
        if (currentDrawer === 'camera') {
          stopCameraStream();
        }
      }
      if (toggleBackdrop) {
        document.getElementById('backdrop')?.classList.remove('show');
      }
      currentDrawer = null;
    }

    window.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape') closeDrawer();
    });

    // Camera streaming functions
    let cameraStreamActive = false;
    function startCameraStream() {
      const img = document.getElementById('camera-stream');
      const status = document.getElementById('camera-status');
      if (!img || !status) return;

      status.textContent = 'Connecting to camera...';
      img.style.display = 'none';

      // Use MJPEG streaming over HTTP instead of WebSocket
      // This is much more efficient than sending frames via MQTT/WebSocket
      const cameraHost = window.location.hostname || 'localhost';
      const cameraPort = '8080'; // Camera service HTTP port
      img.src = `http://${cameraHost}:${cameraPort}/stream`;

      img.onload = () => {
        img.style.display = 'block';
        status.textContent = 'Live MJPEG stream active';
        cameraStreamActive = true;
      };

      img.onerror = () => {
        status.textContent = 'Failed to connect to camera stream';
        cameraStreamActive = false;
      };
    }

    function stopCameraStream() {
      cameraStreamActive = false;
      const img = document.getElementById('camera-stream');
      const status = document.getElementById('camera-status');
      if (img) {
        img.src = '';
        img.style.display = 'none';
      }
      if (status) status.textContent = 'Stream stopped';
    }

    // Remove camera frame handling from WebSocket since we use MJPEG now

  window.addEventListener('load', ()=>{ 
    connect(); 
    drawSpectrum(); 
    setStatus(); 
    refreshMemory(); 
    updateMqttSummary();
    updateHealthButton();
    // Check for health timeouts every 5 seconds
    setInterval(checkHealthTimeouts, 5000);
  });
  </script>
  </head>
<body>
  <header>
    <h1>TARS Chat</h1>
    <div class="toolbar">
      <button class="btn health" onclick="openDrawer('health')" title="System Health">Health <span class="health-indicator"></span></button>
      <button class="btn" onclick="openDrawer('mic')">Microphone</button>
      <button class="btn" onclick="openDrawer('memory')">Memory</button>
      <button class="btn" onclick="openDrawer('stream')">MQTT Stream</button>
      <button class="btn" onclick="openDrawer('camera')">Camera</button>
    </div>
  </header>
  <div id="container">
    <div id="left">
      <div id="chat" class="panel">
        <div id="log"></div>
        <div id="composer">
          <input id="input" placeholder="Type to add a user message (UI-only demo)…" onkeydown="if(event.key==='Enter'){ if(this.value){ addBubble('user', this.value, 'You'); this.value=''; }}" />
          <button onclick="const i=document.getElementById('input'); if(i.value){ addBubble('user', i.value, 'You'); i.value=''; }">Send</button>
        </div>
      </div>
      <div class="panel">
        <div id="states">
          <div id="status-line" class="status">Idle</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Backdrop for drawers -->
  <div id="backdrop" class="backdrop" onclick="closeDrawer()"></div>

  <!-- Microphone Drawer -->
  <aside id="drawer-mic" class="drawer" aria-hidden="true">
    <header>
      <h2>Microphone</h2>
      <button class="close" onclick="closeDrawer()">Close</button>
    </header>
    <div class="content">
      <div id="mic-text" style="color:var(--muted); min-height:20px; margin-bottom:8px;">&nbsp;</div>
      <canvas id="spectrum"></canvas>
    </div>
  </aside>

  <!-- Memory Drawer -->
  <aside id="drawer-memory" class="drawer" aria-hidden="true">
    <header>
      <h2>Memory</h2>
      <button class="close" onclick="closeDrawer()">Close</button>
    </header>
    <div class="content" style="display:flex; flex-direction:column; gap:8px;">
      <div style="display:flex; gap:8px;">
        <input id="mem-query" placeholder="Query (e.g., *)" value="*" style="flex:1; background:#0c1020; color:var(--text); border:1px solid var(--border); padding:8px; border-radius:6px;" />
        <input id="mem-k" type="number" min="1" max="200" value="25" title="Top-K" style="width:80px; background:#0c1020; color:var(--text); border:1px solid var(--border); padding:8px; border-radius:6px;" />
        <button onclick="refreshMemory()" style="background:#0c7bdc; color:#fff; border:none; padding:8px 10px; font-weight:600; border-radius:6px; cursor:pointer;">Refresh</button>
      </div>
      <div id="mem-summary" class="meta">&nbsp;</div>
      <div id="memory-list" style="border-top:1px solid var(--border); padding-top:10px;"></div>
    </div>
  </aside>

  <!-- MQTT Stream Drawer -->
  <aside id="drawer-stream" class="drawer" aria-hidden="true">
    <header>
      <h2>MQTT Stream</h2>
      <button class="close" onclick="closeDrawer()">Close</button>
    </header>
    <div class="content" style="display:flex; flex-direction:column; gap:10px;">
      <div class="mqtt-toolbar">
        <div id="mqtt-summary">0 messages</div>
        <div class="spacer"></div>
        <button onclick="clearMqttLog()">Clear</button>
      </div>
      <div id="mqtt-log"></div>
    </div>
  </aside>

  <!-- Camera Drawer -->
  <aside id="drawer-camera" class="drawer" aria-hidden="true">
    <header>
      <h2>Camera</h2>
      <button class="close" onclick="closeDrawer()">Close</button>
    </header>
    <div class="content">
      <div id="camera-status" style="color:var(--muted); margin-bottom:8px;">Connecting...</div>
      <img id="camera-stream" style="width:100%; max-width:640px; border:1px solid var(--border); border-radius:6px;" alt="Camera feed" />
    </div>
  </aside>

  <!-- Health Drawer -->
  <aside id="drawer-health" class="drawer" aria-hidden="true">
    <header>
      <h2>System Health</h2>
      <button class="close" onclick="closeDrawer()">Close</button>
    </header>
    <div class="content">
      <div id="health-status" style="margin-bottom:16px;">
        <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px;">
          <span id="overall-health" style="font-weight:600;">Checking...</span>
        </div>
        <div id="health-components"></div>
      </div>
    </div>
  </aside>
</body>
</html>